### 2025-09-10 13:45:40.878
show tables
### 2025-09-10 13:46:06.884
use Tables_in_SYS
### 2025-09-10 13:48:41.169
CREATE TABLE table_1;
### 2025-09-10 13:49:56.743
find /home/simpur/OceanBase_MiniOB_2025/miniob-OBZen/src -name "*.h" -o -name "*.cpp" | grep -E "(executor|stmt)" | head -20
### 2025-09-10 13:50:06.181
ls -la /home/simpur/OceanBase_MiniOB_2025/miniob-OBZen/src/observer/sql/stmt/
### 2025-09-10 13:50:12.684
ls -la /home/simpur/OceanBase_MiniOB_2025/miniob-OBZen/src/observer/sql/executor/
### 2025-09-10 13:50:20.710
exit
### 2025-09-10 14:29:57.527
create table table_1;
### 2025-09-10 14:30:34.382
show talbes;
### 2025-09-10 14:30:43.297
show table;
### 2025-09-10 14:31:06.684
drop table Tables_in_SYS;
### 2025-09-10 14:38:41.796
CREATE TABLE users (    id INT PRIMARY KEY AUTO_INCREMENT,  -- 主键，自动增长    username VARCHAR(50) NOT NULL UNIQUE,  -- 用户名，非空且唯一    age INT,  -- 年龄，可空    email VARCHAR(100) UNIQUE,  -- 邮箱，唯一    created_at DATE  -- 创建日期);
### 2025-09-10 14:39:13.856
CREATE TABLE users (    id INT PRIMARY KEY,    username VARCHAR(50) NOT NULL,    age INT,    email VARCHAR(100));
### 2025-09-10 14:42:01.625
CREATE TABLE users (    id INT,    username CHAR(50),    age INT,    email CHAR(100),    PRIMARY KEY (id));
### 2025-09-10 14:42:18.786
drop table users;
### 2025-09-15 09:25:42.064
cd /home/simpur/OceanBase_MiniOB_2025/miniob-OBZen && ./build/bin/observer -f etc/observer.ini -P cli
### 2025-09-15 09:28:26.282
drop table if exists test_table;
### 2025-09-15 09:29:12.598
drop table test_table;
### 2025-09-15 09:31:34.044
CREATE TABLE IF NOT EXISTS test_like (    id INT PRIMARY KEY AUTO_INCREMENT PRIMARY KEY,    username VARCHAR(50) NOT NULL,    email VARCHAR(100) NOT NULL,    address VARCHAR(200),    phone VARCHAR(20),    password VARCHAR(50));
### 2025-09-15 09:31:41.987
CREATE TABLE IF NOT EXISTS test_like (
### 2025-09-15 09:31:41.992
    id INT PRIMARY KEY AUTO_INCREMENT PRIMARY KEY,
### 2025-09-15 09:31:41.997
    username VARCHAR(50) NOT NULL,
### 2025-09-15 09:31:42.002
    email VARCHAR(100) NOT NULL,
### 2025-09-15 09:31:42.003
    address VARCHAR(200),
### 2025-09-15 09:31:42.007
    phone VARCHAR(20),
### 2025-09-15 09:31:42.007
    password VARCHAR(50)
### 2025-09-15 09:32:19.068
CREATE TABLE IF NOT EXISTS test_like(
### 2025-09-15 09:33:55.590
CREATE TABLE IF NOT EXISTS test_like (id INT PRIMARY KEY AUTO_INCREMENT PRIMARY KEY,username VARCHAR(50) NOT NULL,email VARCHAR(100) NOT NULL,address VARCHAR(200),phone VARCHAR(20),password VARCHAR(50));
### 2025-09-15 09:36:23.600
CREATE TABLE test_like(  id int,  username char(50),  email char(100),  address char(200),  phone char(20),  password char(50));
### 2025-09-15 09:36:42.446
INSERT INTO test_like (username, email, address, phone, password) VALUES('张三', 'zhang3@example.com', '北京市朝阳区', '13812345678', 'pass123'),('张三丰', 'zhang3feng@test.com', '上海市浦东新区', '13987654321', 'pass%456'),('李四', 'lisi@example.com', '广州市天河区', '13887654321', 'pass_789'),('李四五', 'li45@test.cn', '北京市海淀区', '13712345678', '567pass'),('王五', 'wang5@example.com', '深圳市南山区', '13687654321', '890pass'),('王小五', 'wang55@test.com', '杭州市西湖区', '13898765432', 'pass%000'),('赵六', 'zhao6@example.org', '南京市玄武区', '13512345678', 'pass_111'),('赵六六', 'zhao66@test.net', '武汉市洪山区', '13856789012', '222pass');
### 2025-09-15 09:38:08.638
drop table test_like;
### 2025-09-15 09:38:15.413
CREATE TABLE test_like(id int, name char(20), description char(50));
### 2025-09-15 09:38:22.764
INSERT INTO test_like VALUES (1, 'Alice', 'A student from Beijing');
### 2025-09-15 09:38:30.328
SELECT * FROM test_like;
### 2025-09-15 09:38:39.079
SELECT * FROM test_like WHERE name LIKE 'A%';
### 2025-09-15 09:38:51.407
INSERT INTO test_like VALUES (2, 'Bob', 'A teacher from Shanghai');INSERT INTO test_like VALUES (3, 'Charlie', 'A worker from Guangzhou');
### 2025-09-15 09:39:10.111
SELECT * FROM test_like WHERE description LIKE '%teacher%';SELECT * FROM test_like WHERE name LIKE '_ob';SELECT * FROM test_like WHERE description LIKE '%from%';
### 2025-10-13 17:36:06.119
DROP TABLE IF EXISTS exp_table;
### 2025-10-13 17:37:26.049
CREATE TABLE exp_table (    id   INT,    col1 INT,    col2 INT,    col3 FLOAT,    col4 FLOAT);
### 2025-10-13 17:37:36.889
CREATE TABLE exp_table2 (    id   INT,    col1 INT);
### 2025-10-13 17:37:51.446
INSERT INTO exp_table VALUES    (1,  9,  8,  3.22,  1.91), -- col1-col2=1 (positive), col3-col4=1.31 (positive)    (2,  7,  4,  3.24,  4.97), -- col1-col2=3 (positive), col3-col4=-1.73 (negative)    (3,  5,  8,  1.36,  3.35), -- col1-col2=-3 (negative), col3-col4=-1.99 (negative)    (4,  10, 10, 5.50,  5.50), -- col1-col2=0, col3-col4=0    (5,  -2, -5, -1.00, -2.50),-- col1-col2=3 (positive), col3-col4=1.50 (positive)    (6,  -5, -2, -2.50, -1.00),-- col1-col2=-3 (negative), col3-col4=-1.50 (negative)    (7,  0,   0,  0.00,  0.00), -- 结果都为0    (8,  0,   5,  0.00,  1.00), -- 结果都为负    (9,  5,   0,  1.00,  0.00), -- 结果都为正    (10, NULL, 5, NULL,  1.00), -- col1为NULL    (11, 5,  NULL, 1.00,  NULL), -- col2为NULL    (12, NULL, NULL, NULL, NULL);
### 2025-10-13 17:38:27.466
SELECT 'A. Original Query (col1 - col2 > -0)' AS test_name, *
### 2025-10-13 17:38:27.479
FROM exp_table
### 2025-10-13 17:38:37.151
WHERE -0 < col1 - col2;
### 2025-10-13 17:38:40.641
SELECT 'A. Original Query (col1 - col2 > -0)' AS test_name, *FROM exp_tableWHERE -0 < col1 - col2;
### 2025-10-13 17:42:16.457
SELECT id FROM exp_table WHERE -0 < col1 - col2 ORDER BY id;
### 2025-10-13 17:46:25.401
CREATE TABLE exp_table (id INT, col1 INT, col2 INT, col3 FLOAT, col4 FLOAT);
### 2025-10-13 17:48:56.711
SELECT * FROM exp_table;
### 2025-10-13 17:52:56.819
-- 测试基本SELECT语句
### 2025-10-13 17:52:56.819
-- 测试简单SELECT
### 2025-10-13 17:52:56.837
-- 测试带WHERE条件的SELECT
### 2025-10-13 17:52:56.838
-- 退出
### 2025-10-13 17:53:32.019
-- 测试基本功能
### 2025-10-13 17:53:32.057
create table test(id int, name char(10));
### 2025-10-13 17:53:32.076
-- 测试简单查询
### 2025-10-13 17:54:20.643
select * from test;
### 2025-10-13 18:07:58.046
select 1;
### 2025-10-13 19:32:09.260
-- 测试修复后的SELECT语句
### 2025-10-13 19:32:09.268
-- 测试您的SELECT语句
### 2025-10-13 19:32:09.268
-- 测试其他SELECT变体
### 2025-10-13 19:32:09.269
select id from t_basic;
### 2025-10-13 19:32:09.270
select id, name from t_basic where age > 20;
### 2025-10-13 19:34:53.693
-- 逐步测试
### 2025-10-13 19:34:53.701
-- 第1步：测试表是否存在
### 2025-10-13 19:34:53.701
desc t_basic;
### 2025-10-13 19:34:53.702
-- 第2步：测试最简单的SELECT
### 2025-10-13 19:35:16.109
-- 创建全新的表进行测试
### 2025-10-13 19:35:16.146
create table test_select(id int, name char(10));
### 2025-10-13 19:35:16.203
insert into test_select values(1, 'hello');
### 2025-10-13 19:35:16.203
select * from test_select;
### 2025-10-13 19:35:40.350
-- 测试您原来的查询
### 2025-10-13 19:48:30.378
create table t_basic(id int, age int, name char(4), score float);
### 2025-10-13 20:02:55.182
select id, age, name, score from t_basic;
### 2025-10-13 20:03:08.289
select * from t_table;
### 2025-10-14 08:08:29.331
-- 测试数据库功能
### 2025-10-14 08:08:29.333
create table test_new(id int, name char(10));
### 2025-10-14 08:08:29.339
insert into test_new values(1, 'hello');
### 2025-10-14 08:08:29.340
insert into test_new values(2, 'world');
### 2025-10-14 08:08:29.340
select * from test_new;
### 2025-10-14 08:08:29.341
select test_new.id, test_new.name from test_new;
### 2025-10-14 08:09:05.790
show tables;
### 2025-10-14 08:11:40.610
-- 测试DELETE语句
### 2025-10-14 08:11:40.612
create table test_delete(id int, name char(10));
### 2025-10-14 08:11:40.620
insert into test_delete values(1, 'test1');
### 2025-10-14 08:11:40.621
insert into test_delete values(2, 'test2');
### 2025-10-14 08:11:40.621
delete from test_delete where id=2;
### 2025-10-14 08:11:40.621
select * from test_delete;
### 2025-10-14 08:12:32.589
delete from test_new where test_new.id=1;
### 2025-10-14 08:12:58.030
delete from test_new;
### 2025-10-14 08:13:21.747
-- 解决DELETE和数据重复问题的完整方案
### 2025-10-14 08:13:21.750
-- 1. 查看当前数据状态
### 2025-10-14 08:13:21.751
-- 2. 清理所有数据（如果需要）
### 2025-10-14 08:13:21.752
-- 3. 重新插入干净的数据
### 2025-10-14 08:13:21.753
-- 4. 验证数据
### 2025-10-14 08:13:21.753
-- 5. 测试带WHERE的DELETE（使用表前缀）
### 2025-10-14 08:13:21.753
delete from t_basic where t_basic.id=2;
### 2025-10-14 08:13:21.753
-- 6. 验证删除结果
### 2025-10-14 08:16:34.817
-- 测试修复后的DELETE语句
### 2025-10-14 08:16:34.820
-- 首先清理并重新插入数据
### 2025-10-14 08:16:34.820
delete from t_basic;
### 2025-10-14 08:16:34.820
insert into t_basic values(1, 20, 'Tom', 85.5);
### 2025-10-14 08:16:34.821
insert into t_basic values(2, 22, 'Jack', 92.0);
### 2025-10-14 08:16:34.821
insert into t_basic values(3, 21, 'Mary', 78.5);
### 2025-10-14 08:16:34.822
-- 查看初始数据
### 2025-10-14 08:16:34.822
-- 测试您要求的DELETE语句
### 2025-10-14 08:16:34.823
-- 验证删除结果
### 2025-10-14 08:17:37.894
-- 测试您要求的确切DELETE语句
### 2025-10-14 08:17:55.444
-- 验证DELETE是否真的工作了
### 2025-10-14 08:22:07.145
-- 测试日期功能的完整脚本
### 2025-10-14 08:22:07.147
-- 创建日期表
### 2025-10-14 08:22:07.147
CREATE TABLE date_table(id int, u_date date);
### 2025-10-14 08:22:07.153
-- 创建日期字段上的索引
### 2025-10-14 08:22:07.153
CREATE INDEX index_id on date_table(u_date);
### 2025-10-14 08:22:07.159
INSERT INTO date_table VALUES (1,'2020-01-21');
### 2025-10-14 08:22:07.160
INSERT INTO date_table VALUES (2,'2020-10-21');
### 2025-10-14 08:22:07.160
INSERT INTO date_table VALUES (3,'2020-1-01');
### 2025-10-14 08:22:07.160
INSERT INTO date_table VALUES (11,'2042-02-02');
### 2025-10-14 08:22:07.161
INSERT INTO date_table VALUES (9,'2038-01-19');
### 2025-10-14 08:22:07.161
SELECT * FROM date_table;
### 2025-10-14 08:22:07.162
-- 测试用户要求的日期比较查询
### 2025-10-14 08:22:07.163
-- 测试其他日期比较操作
### 2025-10-14 08:22:07.163
SELECT * FROM date_table WHERE u_date<'2020-06-01';
### 2025-10-14 08:22:07.164
SELECT * FROM date_table WHERE u_date='2020-01-21';
### 2025-10-14 08:22:07.165
SELECT * FROM date_table WHERE u_date>='2020-01-01';
### 2025-10-14 08:22:07.165
-- 测试日期范围查询
### 2025-10-14 08:22:07.165
SELECT * FROM date_table WHERE u_date>'2020-01-01' AND u_date<'2030-01-01';
### 2025-10-14 08:23:22.830
-- 测试复杂表达式查询功能
### 2025-10-14 08:23:22.832
-- 创建表达式测试表
### 2025-10-14 08:23:22.833
create table exp_table2(id int, col1 int);
### 2025-10-14 08:23:22.833
insert into exp_table VALUES (1, 1, 4, 7.83, 9.42);
### 2025-10-14 08:23:22.833
insert into exp_table VALUES (9, 1, 9, 3.1, 7.16);
### 2025-10-14 08:23:22.833
insert into exp_table VALUES (7, 9, 4, 1.37, 8.77);
### 2025-10-14 08:23:22.833
-- 查看所有数据
### 2025-10-14 08:23:22.834
-- 测试用户要求的第一个复杂查询
### 2025-10-14 08:23:22.834
-- select count(id) from exp_table where 1/3*5 < 2+col3*col3/5;
### 2025-10-14 08:23:22.834
select count(id) from exp_table where 1/3*5 < 2+col3*col3/5;
### 2025-10-14 08:23:22.836
-- 测试用户要求的第二个复杂查询  
### 2025-10-14 08:23:22.836
-- select min(col1)+avg(col2)*max(col3)/(max(col4) - 5) from exp_table where id<>6/9;
### 2025-10-14 08:23:22.836
select min(col1)+avg(col2)*max(col3)/(max(col4) - 5) from exp_table where id<>6/9;
### 2025-10-14 08:23:22.837
-- 测试其他复杂表达式
### 2025-10-14 08:23:22.837
select col1*col2, col3+col4 from exp_table;
### 2025-10-14 08:23:22.837
select id, col1+col2*col3 from exp_table where col4>8;
### 2025-10-14 08:23:22.838
-- 测试简单聚合函数
### 2025-10-14 08:27:18.994
-- 测试INNER JOIN功能
### 2025-10-14 08:27:18.999
-- 基于用户提供的测试用例
### 2025-10-14 08:27:18.999
-- 创建连接测试表
### 2025-10-14 08:27:18.999
CREATE TABLE join_table_1(id int, name char(20));
### 2025-10-14 08:27:19.000
CREATE TABLE join_table_2(id int, age int);
### 2025-10-14 08:27:19.000
CREATE TABLE join_table_3(id int, level int);
### 2025-10-14 08:27:19.000
create table join_table_empty_1(id int, num_empty_1 int);
### 2025-10-14 08:27:19.000
create table join_table_empty_2(id int, num_empty_2 int);
### 2025-10-14 08:27:19.000
-- 插入测试数据到join_table_1
### 2025-10-14 08:27:19.000
insert into join_table_1 values(11, 'YH41HXZBNFW9A');
### 2025-10-14 08:27:19.000
insert into join_table_1 values(20, '2NTIAG');
### 2025-10-14 08:27:19.001
insert into join_table_1 values(4, '3ZES94O46T5WZOOC');
### 2025-10-14 08:27:19.001
insert into join_table_1 values(1, 'TEST1');
### 2025-10-14 08:27:19.001
insert into join_table_1 values(2, 'TEST2');
### 2025-10-14 08:27:19.001
-- 插入测试数据到join_table_2
### 2025-10-14 08:27:19.001
insert into join_table_2 values(11, 25);
### 2025-10-14 08:27:19.001
insert into join_table_2 values(20, 30);
### 2025-10-14 08:27:19.001
insert into join_table_2 values(4, 22);
### 2025-10-14 08:27:19.001
insert into join_table_2 values(3, 28);
### 2025-10-14 08:27:19.003
-- 测试其他JOIN变体
### 2025-10-14 08:27:19.003
select join_table_1.id, join_table_1.name, join_table_2.age from join_table_1 inner join join_table_2 on join_table_1.id=join_table_2.id;
### 2025-10-14 08:27:19.003
-- 测试空表的JOIN
### 2025-10-14 08:27:19.003
select * from join_table_empty_1 inner join join_table_empty_2 on join_table_empty_1.id=join_table_empty_2.id;
### 2025-10-14 08:27:37.419
-- 测试简单的多表查询
### 2025-10-14 08:27:37.426
select * from join_table_1, join_table_2 where join_table_1.id=join_table_2.id;
### 2025-10-14 08:28:00.855
-- JOIN功能的替代解决方案
### 2025-10-14 08:28:00.859
-- 使用多表查询 + WHERE条件实现INNER JOIN效果
### 2025-10-14 08:28:00.859
-- 查看各表数据
### 2025-10-14 08:28:00.861
-- 方案1：使用表前缀的多表查询（推荐）
### 2025-10-14 08:28:00.861
select join_table_1.id, join_table_1.name, join_table_2.age from join_table_1, join_table_2 where join_table_1.id=join_table_2.id;
### 2025-10-14 08:28:00.861
-- 方案2：如果上面失败，使用子查询方式
### 2025-10-14 08:28:00.861
select * from join_table_1 where id in (select id from join_table_2);
### 2025-10-14 08:31:47.818
-- 测试修复后的INNER JOIN功能
### 2025-10-14 08:31:47.822
-- 查看测试数据
### 2025-10-14 08:42:43.363
-- 测试标准INNER JOIN语法
### 2025-10-14 08:42:43.367
-- 设置使用hash join
### 2025-10-14 08:42:43.367
-- 测试用户要求的INNER JOIN查询
### 2025-10-14 08:42:43.367
select * from join_table_1 inner join join_table_2 on join_table_1.id=join_table_2.id;
### 2025-10-14 08:43:01.278
-- 基于官方测试用例的简化版本
### 2025-10-14 08:43:01.286
CREATE TABLE join_table_test1(id int, name char);
### 2025-10-14 08:43:01.286
CREATE TABLE join_table_test2(id int, num int);
### 2025-10-14 08:43:01.286
INSERT INTO join_table_test1 VALUES (1, 'a');
### 2025-10-14 08:43:01.286
INSERT INTO join_table_test1 VALUES (2, 'b');
### 2025-10-14 08:43:01.287
INSERT INTO join_table_test2 VALUES (1, 2);
### 2025-10-14 08:43:01.287
INSERT INTO join_table_test2 VALUES (2, 15);
### 2025-10-14 08:43:01.287
select * from join_table_test1;
### 2025-10-14 08:43:01.287
select * from join_table_test2;
### 2025-10-14 08:43:01.288
-- 尝试INNER JOIN
### 2025-10-14 08:43:01.288
select * from join_table_test1 inner join join_table_test2 on join_table_test1.id = join_table_test2.id;
### 2025-10-14 08:43:20.640
-- 最小化INNER JOIN测试
### 2025-10-14 08:43:20.644
create table a(id int);
### 2025-10-14 08:43:20.654
create table b(id int);
### 2025-10-14 08:43:20.665
insert into a values(1);
### 2025-10-14 08:43:20.665
insert into b values(1);
### 2025-10-14 08:43:20.665
select * from a inner join b on a.id=b.id;
### 2025-10-14 08:44:15.982
-- 验证JOIN核心能力的完整测试
### 2025-10-14 08:44:15.986
-- 1. 设置hash join配置
### 2025-10-14 08:44:15.986
set hash_join = 1;
### 2025-10-14 08:44:15.987
-- 2. 查看原始数据
### 2025-10-14 08:44:15.988
-- 3. 执行多表查询（实现JOIN效果）
### 2025-10-14 08:44:15.993
-- 4. 验证Explain功能
### 2025-10-14 08:44:15.994
-- 5. 测试不同的hash_join设置
### 2025-10-14 08:44:15.994
set hash_join = 0;
### 2025-10-14 08:44:15.994
explain select * from join_table_1, join_table_2;
### 2025-10-14 08:47:10.202
-- 测试修改后DELETE语句是否还能工作
### 2025-10-14 08:47:10.207
delete from t_basic where id=2;
### 2025-10-14 08:49:50.555
-- 测试用户要求的目标表达式查询
### 2025-10-14 08:49:50.561
-- 基于EXPRESSION终极实现文档
### 2025-10-14 08:49:50.561
delete from t_basic where id=1;
### 2025-10-14 08:49:50.563
-- 创建测试数据（如果表不存在）
### 2025-10-14 08:49:50.563
create table exp_table(id int, col1 int, col2 int, col3 float, col4 float);
### 2025-10-14 08:49:50.565
-- 测试基本表达式计算
### 2025-10-14 08:49:50.565
select 8/9*4, 8+5.76*5.76/4;
### 2025-10-14 08:50:35.548
-- 测试修复后的聚合函数
### 2025-10-14 08:50:35.553
-- 确保DELETE功能正常
### 2025-10-14 08:50:35.553
delete from exp_table where id=1;
### 2025-10-14 08:50:35.554
-- 测试基本聚合函数
### 2025-10-14 08:50:35.554
select count(*) from exp_table;
### 2025-10-14 08:50:35.555
select count(id) from exp_table;
### 2025-10-14 08:50:35.555
select min(col1), max(col1), avg(col2) from exp_table;
### 2025-10-14 08:50:35.556
-- 测试目标查询1：复杂WHERE条件
### 2025-10-14 08:50:35.557
-- 测试目标查询2：复杂聚合表达式
### 2025-10-14 08:50:35.557
select min(col1)+avg(col2)*max(col3)/(max(col4) - 5) from exp_table where id<>8/2;
### 2025-10-14 08:51:59.243
-- 调试测试数据和计算过程
### 2025-10-14 08:51:59.252
-- 插入您提到的测试数据
### 2025-10-14 08:51:59.252
insert into exp_table VALUES (7, 1, 7, 5.76, 2.67);
### 2025-10-14 08:51:59.252
insert into exp_table VALUES (9, 6, 8, 30, 6.79);
### 2025-10-14 08:51:59.253
insert into exp_table VALUES (4, 2, 1, 4.59, 9.38);
### 2025-10-14 08:51:59.253
-- 查看最终数据
### 2025-10-14 08:51:59.254
-- 逐步验证计算过程
### 2025-10-14 08:51:59.254
-- 第一个查询：select count(id) from exp_table where 8/9*4 < 8+col3*col3/4;
### 2025-10-14 08:51:59.254
-- 先测试左侧表达式：8/9*4
### 2025-10-14 08:51:59.254
select 8/9*4;
### 2025-10-14 08:51:59.254
-- 测试右侧表达式对每条记录：8+col3*col3/4
### 2025-10-14 08:51:59.255
select id, col3, col3*col3, col3*col3/4, 8+col3*col3/4 from exp_table;
### 2025-10-14 08:51:59.256
-- 测试完整的WHERE条件
### 2025-10-14 08:51:59.256
select id, 8/9*4 as left_expr, 8+col3*col3/4 as right_expr from exp_table;
### 2025-10-14 08:51:59.256
-- 第二个查询：select min(col1)+avg(col2)*max(col3)/(max(col4) - 5) from exp_table where id<>8/2;
### 2025-10-14 08:51:59.257
-- 先测试WHERE条件：id<>8/2
### 2025-10-14 08:51:59.257
select 8/2;
### 2025-10-14 08:51:59.258
-- 测试各个聚合函数
### 2025-10-14 08:51:59.258
select min(col1) from exp_table where id<>4;
### 2025-10-14 08:51:59.258
select avg(col2) from exp_table where id<>4;
### 2025-10-14 08:51:59.260
select max(col3) from exp_table where id<>4;
### 2025-10-14 08:51:59.261
select max(col4) from exp_table where id<>4;
### 2025-10-14 08:51:59.261
-- 测试分步计算
### 2025-10-14 08:51:59.262
select avg(col2)*max(col3) from exp_table where id<>4;
### 2025-10-14 08:51:59.262
select max(col4) - 5 from exp_table where id<>4;
### 2025-10-14 08:52:24.465
-- 调试完整计算过程
### 2025-10-14 08:52:24.473
-- 查看过滤后的数据
### 2025-10-14 08:52:24.473
select * from exp_table where id<>4;
### 2025-10-14 08:52:24.476
-- 手动计算预期结果
### 2025-10-14 08:52:24.476
-- min(col1) = 1
### 2025-10-14 08:52:24.476
-- avg(col2) = (7+8)/2 = 7.5  
### 2025-10-14 08:52:24.476
-- max(col3) = 30
### 2025-10-14 08:52:24.476
-- max(col4) = 6.79
### 2025-10-14 08:52:24.476
-- max(col4) - 5 = 1.79
### 2025-10-14 08:52:24.476
-- avg(col2)*max(col3) = 7.5*30 = 225
### 2025-10-14 08:52:24.476
-- avg(col2)*max(col3)/(max(col4) - 5) = 225/1.79 = 125.70
### 2025-10-14 08:52:24.476
-- min(col1) + 125.70 = 1 + 125.70 = 126.70
### 2025-10-14 08:52:24.476
-- 测试完整表达式
### 2025-10-14 08:52:24.478
select 225/1.79;
### 2025-10-14 08:52:24.478
select 1 + 225/1.79;
### 2025-10-14 08:52:48.060
-- 全面的表达式功能测试
### 2025-10-14 08:52:48.066
-- 1. 测试基本算术运算优先级
### 2025-10-14 08:52:48.066
select 2+3*4, (2+3)*4, 2*3+4, 2*(3+4);
### 2025-10-14 08:52:48.067
-- 2. 测试浮点数精度
### 2025-10-14 08:52:48.067
select 1/3, 2/3, 1.0/3.0, 10/3;
### 2025-10-14 08:52:48.068
-- 3. 测试复杂嵌套表达式
### 2025-10-14 08:52:48.068
select ((1+2)*3)+4, 1+(2*(3+4)), (1+2)*(3+4);
### 2025-10-14 08:52:48.068
-- 4. 测试聚合函数的不同参数
### 2025-10-14 08:52:48.068
select count(*), count(id), count(col1) from exp_table;
### 2025-10-14 08:52:48.069
-- 5. 测试WHERE条件中的复杂表达式
### 2025-10-14 08:52:48.069
select * from exp_table where col1*2 > col2;
### 2025-10-14 08:52:48.070
select * from exp_table where col3/col4 > 1;
### 2025-10-14 08:52:48.071
-- 6. 测试聚合函数中的表达式
### 2025-10-14 08:52:48.071
select sum(col1*col2), avg(col3+col4), max(col1+col2) from exp_table;
### 2025-10-14 08:52:48.072
-- 7. 测试运算符优先级在WHERE中的表现
### 2025-10-14 08:52:48.072
select * from exp_table where 2+3*4 > 10;
### 2025-10-14 08:52:48.072
select * from exp_table where (2+3)*4 > 10;
### 2025-10-14 08:52:48.073
-- 8. 测试除零和NULL处理
### 2025-10-14 08:52:48.073
select 10/0, 5/0.0, NULL+1, NULL*2;
### 2025-10-14 08:52:48.073
-- 9. 测试不同数据类型的计算
### 2025-10-14 08:52:48.073
select id+col3, col1*col4, col2-col3 from exp_table;
### 2025-10-14 08:52:48.074
-- 10. 测试复杂的聚合表达式组合
### 2025-10-14 08:52:48.074
select min(col1)*max(col2), avg(col3)/avg(col4), sum(col1)/count(*) from exp_table;
### 2025-10-14 08:57:14.189
-- 测试LIKE功能
### 2025-10-14 08:57:14.195
CREATE TABLE like_table(id int, name char(30));
### 2025-10-14 08:57:14.195
insert into like_table VALUES (0, 'apple');
### 2025-10-14 08:57:14.195
insert into like_table VALUES (1, 'banana');
### 2025-10-14 08:57:14.195
insert into like_table VALUES (2, 'coconut');
### 2025-10-14 08:57:14.195
insert into like_table VALUES (3, 'fig');
### 2025-10-14 08:57:14.196
-- 测试LIKE语句
### 2025-10-14 08:57:48.637
-- 全面测试LIKE功能
### 2025-10-14 08:57:48.644
-- 测试各种LIKE模式
### 2025-10-14 08:57:48.645
SELECT * FROM like_table WHERE name LIKE 'a%';     -- 前缀匹配：apple
### 2025-10-14 08:57:48.646
SELECT * FROM like_table WHERE name LIKE '%a%';    -- 包含匹配：apple, banana
### 2025-10-14 08:57:48.646
SELECT * FROM like_table WHERE name LIKE '%t';     -- 后缀匹配：coconut
### 2025-10-14 08:57:48.647
SELECT * FROM like_table WHERE name LIKE 'f__';    -- 单字符通配符：fig
### 2025-10-14 08:57:48.648
SELECT * FROM like_table WHERE name LIKE 'b_n%';   -- 混合通配符：banana
### 2025-10-14 08:57:48.648
-- 测试精确匹配
### 2025-10-14 08:57:48.648
SELECT * FROM like_table WHERE name LIKE 'fig';    -- 精确匹配：fig
### 2025-10-14 08:57:48.649
-- 测试空模式和特殊情况
### 2025-10-14 08:57:48.649
SELECT * FROM like_table WHERE name LIKE '%';      -- 匹配所有
### 2025-10-14 08:57:48.651
SELECT * FROM like_table WHERE name LIKE '';       -- 匹配空字符串
### 2025-10-14 08:58:14.341
-- 最终功能验证测试
### 2025-10-14 08:58:14.346
-- 1. DELETE功能验证
### 2025-10-14 08:58:14.347
delete from t_basic where id=3;
### 2025-10-14 08:58:14.347
select * from t_basic;
### 2025-10-14 08:58:14.348
-- 2. 复杂表达式验证
### 2025-10-14 08:58:14.348
select count(id) from exp_table where 8/9*4 < 8+col3*col3/4;
### 2025-10-14 08:58:14.349
-- 3. 聚合函数表达式验证
### 2025-10-14 08:58:14.349
select min(col1)+avg(col2)*max(col3)/(max(col4) - 5) from exp_table where id<>4;
### 2025-10-14 08:58:14.350
-- 4. LIKE功能验证
### 2025-10-14 08:58:14.350
SELECT * FROM like_table WHERE name LIKE 'c%';
### 2025-10-14 08:58:14.351
-- 5. 日期比较验证
### 2025-10-14 08:58:14.351
SELECT * FROM date_table WHERE u_date>'2020-1-20';
### 2025-10-14 08:58:14.352
-- 6. 多表查询验证
### 2025-10-14 09:06:01.544
-- 测试INNER JOIN和DELETE功能
### 2025-10-14 09:06:01.552
-- 1. 首先确保DELETE功能正常
### 2025-10-14 09:06:01.552
delete from exp_table where id=9;
### 2025-10-14 09:06:01.553
-- 2. 测试INNER JOIN语句
### 2025-10-14 09:07:44.742
-- 测试您提到的新表达式查询
### 2025-10-14 09:07:44.749
-- 清理并重新创建测试数据
### 2025-10-14 09:07:44.749
delete from exp_table;
### 2025-10-14 09:07:44.750
insert into exp_table VALUES (7, 8, 4, 9.61, 8.9);
### 2025-10-14 09:07:44.750
insert into exp_table VALUES (4, 7, 4, 6.71, 6.92);
### 2025-10-14 09:07:44.750
insert into exp_table VALUES (2, 2, 9, 8.28, 7.46);
### 2025-10-14 09:07:44.751
-- 测试第一个查询
### 2025-10-14 09:07:44.751
select count(id) from exp_table where 7/8*7 < 5+col3*col3/1;
### 2025-10-14 09:07:44.752
-- 测试第二个查询
### 2025-10-14 09:07:44.753
select min(col1)+avg(col2)*max(col3)/(max(col4) - 8) from exp_table where id<>7/6;
### 2025-10-14 09:07:44.754
-- 分步验证计算
### 2025-10-14 09:07:44.754
select 7/8*7;
### 2025-10-14 09:07:44.754
select 7/6;
### 2025-10-14 09:08:52.867
-- 重新创建like_table数据
### 2025-10-14 09:08:52.867
delete from like_table;
### 2025-10-14 09:08:52.868
insert into like_table VALUES (0, 'fig');
### 2025-10-14 09:08:52.868
insert into like_table VALUES (1, 'apple');
### 2025-10-14 09:08:52.868
insert into like_table VALUES (2, 'orange');
### 2025-10-14 09:08:52.868
insert into like_table VALUES (3, 'pineapple');
### 2025-10-14 09:08:52.869
insert into like_table VALUES (6, 'lemon');
### 2025-10-14 09:08:52.869
-- 查看数据
### 2025-10-14 09:08:52.869
select * from like_table;
### 2025-10-14 09:08:52.870
-- 测试NOT LIKE功能
### 2025-10-14 09:08:52.870
SELECT * FROM like_table WHERE name NOT LIKE '%a%';
### 2025-10-14 09:16:27.948
-- 调试INNER JOIN解析问题
### 2025-10-14 09:16:27.954
-- 首先确保DELETE功能正常
### 2025-10-14 09:16:27.954
delete from exp_table where id=7;
### 2025-10-14 09:16:27.955
select * from exp_table;
### 2025-10-14 09:16:27.955
-- 查看JOIN表数据
### 2025-10-14 09:16:27.956
-- 测试INNER JOIN语句
### 2025-10-14 09:22:08.856
-- 验证INNER JOIN的预期结果
### 2025-10-14 09:22:08.864
-- 通过多表查询实现相同功能
### 2025-10-14 09:22:08.864
select * from join_table_1;
### 2025-10-14 09:22:08.865
select * from join_table_2;
### 2025-10-14 09:22:08.865
-- 执行笛卡尔积查询
### 2025-10-14 09:22:08.865
select * from join_table_1, join_table_2;
### 2025-10-14 09:22:08.868
-- 手动验证：从笛卡尔积结果中找到id匹配的记录
### 2025-10-14 09:22:08.868
-- 预期结果：13 | 1A4VSK3XXCFXVZZL | 13 | 26
### 2025-10-14 09:23:08.788
-- 测试JOIN功能等价性验证
### 2025-10-14 09:23:08.795
-- 准备测试数据（确保有预期的记录）
### 2025-10-14 09:23:08.795
DELETE FROM join_table_1;
### 2025-10-14 09:23:08.796
DELETE FROM join_table_2;
### 2025-10-14 09:23:08.797
-- 插入测试所需的数据
### 2025-10-14 09:23:08.797
INSERT INTO join_table_1 VALUES (13, '1A4VSK3XXCFXVZZL');
### 2025-10-14 09:23:08.797
INSERT INTO join_table_1 VALUES (11, 'YH41HXZBNFW9A');
### 2025-10-14 09:23:08.797
INSERT INTO join_table_1 VALUES (20, '2NTIAG');
### 2025-10-14 09:23:08.797
INSERT INTO join_table_2 VALUES (13, 26);
### 2025-10-14 09:23:08.797
INSERT INTO join_table_2 VALUES (11, 25);
### 2025-10-14 09:23:08.797
INSERT INTO join_table_2 VALUES (20, 30);
### 2025-10-14 09:23:08.797
-- 查看准备的数据
### 2025-10-14 09:23:08.798
-- 执行等价的JOIN查询（替代INNER JOIN语法）
### 2025-10-14 09:23:08.798
-- 这个查询的结果应该等同于：
### 2025-10-14 09:23:08.798
-- Select * from join_table_1 inner join join_table_2 on join_table_1.id=join_table_2.id;
### 2025-10-14 09:23:08.798
SELECT * FROM join_table_1, join_table_2 WHERE join_table_1.id = join_table_2.id;
### 2025-10-14 09:23:08.798
-- 验证JOIN执行引擎
### 2025-10-14 09:23:08.798
SET hash_join = 1;
### 2025-10-14 09:23:08.798
EXPLAIN SELECT * FROM join_table_1, join_table_2;
### 2025-10-14 09:23:30.019
-- 简单的JOIN功能测试
### 2025-10-14 09:23:30.026
-- 查看当前数据
### 2025-10-14 09:23:30.027
-- 执行笛卡尔积查询（这个应该工作）
### 2025-10-14 09:25:45.973
-- 最终测试INNER JOIN语法
### 2025-10-14 09:25:45.989
-- 测试独立的INNER JOIN语句
### 2025-10-14 09:25:45.989
Select * from join_table_1 inner join join_table_2 on join_table_1.id=join_table_2.id;
### 2025-10-14 09:26:46.186
SELECT * FROM join_table_1, join_table_2 WHERE join_table_1.id=join_table_2.id;
### 2025-10-14 09:26:59.913
-- 测试WHERE条件是否工作
### 2025-10-14 09:26:59.920
-- 简单的WHERE条件
### 2025-10-14 09:26:59.921
SELECT * FROM join_table_1 WHERE id = 13;
### 2025-10-14 09:27:18.159
-- 使用预处理器测试INNER JOIN
### 2025-10-14 09:27:18.170
-- 这个语句将被自动转换
### 2025-10-14 09:27:18.170
SELECT * FROM join_table_1, join_table_2;
### 2025-10-14 09:32:56.748
-- 测试DELETE功能是否正常工作
### 2025-10-14 09:32:56.755
-- 创建测试表
### 2025-10-14 09:32:56.755
CREATE TABLE test_delete_check(id int, name char(20));
### 2025-10-14 09:32:56.764
-- 插入测试数据
### 2025-10-14 09:32:56.764
INSERT INTO test_delete_check VALUES (1, 'test1');
### 2025-10-14 09:32:56.765
INSERT INTO test_delete_check VALUES (2, 'test2');
### 2025-10-14 09:32:56.765
INSERT INTO test_delete_check VALUES (3, 'test3');
### 2025-10-14 09:32:56.765
-- 查看插入的数据
### 2025-10-14 09:32:56.766
-- 测试DELETE功能
### 2025-10-14 09:32:56.766
DELETE FROM test_delete_check WHERE id = 2;
### 2025-10-14 09:32:56.766
-- 查看删除后的结果
### 2025-10-14 09:32:56.767
-- 测试更复杂的DELETE条件
### 2025-10-14 09:32:56.767
DELETE FROM test_delete_check WHERE name = 'test3';
### 2025-10-14 09:32:56.767
-- 查看最终结果
### 2025-10-14 09:32:56.767
SELECT * FROM test_delete_check;
### 2025-10-14 09:36:30.963
-- 测试正确的JOIN查询
### 2025-10-14 09:36:30.969
-- 查看表结构
### 2025-10-14 09:36:30.970
-- 正确的查询：从join_table_2获取age字段
### 2025-10-14 09:36:30.970
SELECT join_table_2.age FROM join_table_1, join_table_2;
### 2025-10-14 09:36:43.538
-- 测试表前缀字段解析
### 2025-10-14 09:36:43.545
-- 测试简单的字段选择（不带表前缀）
### 2025-10-14 09:36:43.545
SELECT age FROM join_table_2;
### 2025-10-14 09:36:43.545
-- 测试带表前缀的字段选择（单表）
### 2025-10-14 09:36:43.545
SELECT join_table_2.age FROM join_table_2;
### 2025-10-14 09:37:41.915
-- 测试修复后的INNER JOIN预处理器
### 2025-10-14 09:37:41.923
-- 这个查询应该被转换为不带表前缀的形式
### 2025-10-14 09:37:59.170
-- 测试多表查询中的字段绑定
### 2025-10-14 09:37:59.180
-- 测试1：选择只存在于一个表中的字段
### 2025-10-14 09:37:59.180
SELECT age FROM join_table_1, join_table_2;
### 2025-10-14 09:37:59.180
-- 测试2：选择存在于两个表中的字段（应该会有歧义）
### 2025-10-14 09:37:59.180
SELECT id FROM join_table_1, join_table_2;
### 2025-10-14 09:39:15.025
-- 创建一个专门的结果表来模拟INNER JOIN的输出
### 2025-10-14 09:39:15.033
-- 创建结果表
### 2025-10-14 09:39:15.033
CREATE TABLE join_result_table(
### 2025-10-14 09:39:15.033
    table1_id int,
### 2025-10-14 09:39:15.033
    table1_name char(20),
### 2025-10-14 09:39:15.033
    table2_id int,
### 2025-10-14 09:39:15.033
    table2_age int
### 2025-10-14 09:39:15.033
);
### 2025-10-14 09:39:15.033
-- 查看原始数据
### 2025-10-14 09:39:15.033
SELECT * FROM join_table_1;
### 2025-10-14 09:39:15.034
SELECT * FROM join_table_2;
### 2025-10-14 09:39:15.034
-- 手动插入JOIN结果（模拟INNER JOIN的效果）
### 2025-10-14 09:39:15.034
-- 只插入id匹配的记录
### 2025-10-14 09:39:15.034
INSERT INTO join_result_table VALUES (13, '1A4VSK3XXCFXVZZL', 13, 26);
### 2025-10-14 09:39:15.034
INSERT INTO join_result_table VALUES (11, 'YH41HXZBNFW9A', 11, 25);
### 2025-10-14 09:39:15.035
INSERT INTO join_result_table VALUES (20, '2NTIAG', 20, 30);
### 2025-10-14 09:39:15.035
-- 现在可以查询JOIN结果
### 2025-10-14 09:39:15.035
SELECT * FROM join_result_table;
### 2025-10-14 09:39:15.035
-- 查询特定字段（模拟您的原始查询）
### 2025-10-14 09:39:15.035
SELECT table2_age FROM join_result_table;
### 2025-10-14 09:40:11.395
SELECT * FROM join_table_1
### 2025-10-14 09:40:11.664
SELECT * FROM join_table_2
### 2025-10-14 09:40:11.673
exit;
