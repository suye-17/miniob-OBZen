# MiniOB ç®€å•å­æŸ¥è¯¢å®Œæ•´å®ç°æ–‡æ¡£

## æ–‡æ¡£æ¦‚è§ˆ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-16  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæ•´å½’æ¡£  
**åŠŸèƒ½çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  

---

## 1. åŠŸèƒ½æ¦‚è¿°

### 1.1 å®ç°åŠŸèƒ½

MiniOB æ•°æ®åº“ç³»ç»Ÿå·²å®Œæ•´å®ç°ç®€å•å­æŸ¥è¯¢åŠŸèƒ½ï¼Œæ”¯æŒï¼š

- âœ… **IN/NOT IN**: æ”¯æŒå€¼åˆ—è¡¨å’Œå­æŸ¥è¯¢ä¸¤ç§å½¢å¼
  - `WHERE col IN (1, 2, 3)` - å€¼åˆ—è¡¨å½¢å¼
  - `WHERE col IN (SELECT id FROM table)` - å­æŸ¥è¯¢å½¢å¼
- âœ… **EXISTS/NOT EXISTS**: å­˜åœ¨æ€§æ£€æŸ¥å­æŸ¥è¯¢
  - `WHERE EXISTS (SELECT * FROM table WHERE condition)`
- âœ… **æ ‡é‡å­æŸ¥è¯¢æ¯”è¾ƒ**: æ”¯æŒæ‰€æœ‰æ¯”è¾ƒè¿ç®—ç¬¦
  - `WHERE col = (SELECT MAX(id) FROM table)`
  - æ”¯æŒ `=, >, <, >=, <=, !=` è¿ç®—ç¬¦
- âœ… **èšåˆå‡½æ•°å­æŸ¥è¯¢**: æ”¯æŒæ‰€æœ‰èšåˆå‡½æ•°
  - `COUNT, SUM, AVG, MAX, MIN` ç­‰
- âœ… **å¤šåˆ—æ£€æŸ¥**: ä¸¥æ ¼æ£€æŸ¥å­æŸ¥è¯¢è¿”å›åˆ—æ•°
  - IN/æ ‡é‡å­æŸ¥è¯¢å¿…é¡»è¿”å›å•åˆ—ï¼Œå¦åˆ™è¿”å› `FAILURE`
- âœ… **NULLå€¼å¤„ç†**: å®Œæ•´çš„SQLæ ‡å‡†NULLè¯­ä¹‰
- âœ… **ç»“æœç¼“å­˜**: SubqueryExecutoræ”¯æŒç»“æœç¼“å­˜ä¼˜åŒ–
- âœ… **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯æ£€æµ‹å’ŒFAILUREè¾“å‡º

### 1.2 æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§ | è¯´æ˜ | çŠ¶æ€ |
|-----|------|------|
| è¯­æ³•è§£æ | yaccè¯­æ³•è§„åˆ™æ”¯æŒæ‰€æœ‰å­æŸ¥è¯¢å½¢å¼ | âœ… å®Œæˆ |
| è¡¨è¾¾å¼ç³»ç»Ÿ | InExpr, ExistsExpr, SubqueryExpr ç»Ÿä¸€æ¶æ„ | âœ… å®Œæˆ |
| å­æŸ¥è¯¢æ‰§è¡Œå™¨ | ä¸“ç”¨çš„ SubqueryExecutor ç±» | âœ… å®Œæˆ |
| åˆ—æ•°æ£€æŸ¥ | ä¸¥æ ¼çš„å•åˆ—/å¤šåˆ—éªŒè¯ | âœ… å®Œæˆ |
| NULLå¤„ç† | SQLæ ‡å‡†çš„ä¸‰å€¼é€»è¾‘ | âœ… å®Œæˆ |
| æ€§èƒ½ä¼˜åŒ– | ç»“æœç¼“å­˜å’Œæ™ºèƒ½æ‰§è¡Œ | âœ… å®Œæˆ |
| æµ‹è¯•è¦†ç›– | å…¨é¢çš„åŠŸèƒ½å’Œè¾¹ç•Œæµ‹è¯• | âœ… å®Œæˆ |

---

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 å®Œæ•´æ‰§è¡Œæµç¨‹

```
ç”¨æˆ·SQLè¾“å…¥
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. è¯æ³•/è¯­æ³•åˆ†æ                  â”‚
â”‚  æ–‡ä»¶: yacc_sql.y, lex_sql.l     â”‚
â”‚  åŠŸèƒ½: è§£æå­æŸ¥è¯¢è¯­æ³•             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. è¡¨è¾¾å¼åˆ›å»º                    â”‚
â”‚  æ–‡ä»¶: yacc_sql.y (line 800+)    â”‚
â”‚  åŠŸèƒ½: åˆ›å»º InExpr/ExistsExpr     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. å­—æ®µç»‘å®š                      â”‚
â”‚  æ–‡ä»¶: expression_binder.cpp     â”‚
â”‚  åŠŸèƒ½: ç»‘å®šå­æŸ¥è¯¢ä¸­çš„å­—æ®µ         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. å­æŸ¥è¯¢æ‰§è¡Œ                    â”‚
â”‚  æ–‡ä»¶: subquery_executor.cpp     â”‚
â”‚  åŠŸèƒ½: æ‰§è¡Œå­æŸ¥è¯¢è·å–ç»“æœ         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. ç»“æœæ¯”è¾ƒ                      â”‚
â”‚  æ–‡ä»¶: expression.cpp            â”‚
â”‚  åŠŸèƒ½: IN/EXISTS/æ¯”è¾ƒè¿ç®—         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
ç»“æœè¾“å‡º
```

### 2.2 æ ¸å¿ƒæ•°æ®ç»“æ„

#### InExpr (è¡¨è¾¾å¼å±‚)

```cpp
/**
 * @brief IN/NOT IN è¡¨è¾¾å¼
 * @file src/observer/sql/expr/expression.h (668-700è¡Œ)
 */
class InExpr : public Expression
{
public:
  // IN (subquery) æ„é€ å‡½æ•°
  InExpr(bool is_not, std::unique_ptr<Expression> left, std::unique_ptr<Expression> subquery);
  
  // IN (value_list) æ„é€ å‡½æ•°
  InExpr(bool is_not, std::unique_ptr<Expression> left, std::vector<std::unique_ptr<Expression>> &&value_list);
  
private:
  bool                                     is_not_;      // trueè¡¨ç¤ºNOT IN
  std::unique_ptr<Expression>              left_;        // å·¦ä¾§è¡¨è¾¾å¼
  std::unique_ptr<Expression>              subquery_;    // å­æŸ¥è¯¢ï¼ˆå­æŸ¥è¯¢å½¢å¼ï¼‰
  std::vector<std::unique_ptr<Expression>> value_list_;  // å€¼åˆ—è¡¨ï¼ˆå€¼åˆ—è¡¨å½¢å¼ï¼‰
  bool                                     is_subquery_; // æ˜¯å¦ä¸ºå­æŸ¥è¯¢å½¢å¼
  mutable Session                         *session_ = nullptr;
};
```

#### ExistsExpr (è¡¨è¾¾å¼å±‚)

```cpp
/**
 * @brief EXISTS/NOT EXISTS è¡¨è¾¾å¼
 * @file src/observer/sql/expr/expression.h (702-720è¡Œ)
 */
class ExistsExpr : public Expression
{
public:
  ExistsExpr(bool is_not, std::unique_ptr<Expression> subquery);
  
private:
  bool                        is_not_;    // trueè¡¨ç¤ºNOT EXISTS
  std::unique_ptr<Expression> subquery_;  // å­æŸ¥è¯¢è¡¨è¾¾å¼
  mutable Session            *session_ = nullptr;
};
```

#### SubqueryExecutor (æ‰§è¡Œå±‚)

```cpp
/**
 * @brief å­æŸ¥è¯¢æ‰§è¡Œå™¨
 * @file src/observer/sql/expr/subquery_executor.h (30-70è¡Œ)
 */
class SubqueryExecutor
{
public:
  /**
   * @brief æ‰§è¡Œå­æŸ¥è¯¢
   * @param select_node å­æŸ¥è¯¢è¯­æ³•èŠ‚ç‚¹
   * @param session ä¼šè¯ä¸Šä¸‹æ–‡
   * @param results è¾“å‡ºç»“æœ
   * @param check_single_column æ˜¯å¦æ£€æŸ¥åªè¿”å›å•åˆ—ï¼ˆINå’Œæ ‡é‡å­æŸ¥è¯¢éœ€è¦ï¼ŒEXISTSä¸éœ€è¦ï¼‰
   */
  RC execute_subquery(const SelectSqlNode *select_node, 
                      Session *session, 
                      std::vector<Value> &results, 
                      bool check_single_column = true);
                      
private:
  std::unordered_map<std::string, std::vector<Value>> cache_; // ç»“æœç¼“å­˜
};
```

---

## 3. è¯­æ³•å±‚å®ç°

### 3.1 yaccè¯­æ³•è§„åˆ™

**æ–‡ä»¶**: `src/observer/sql/parser/yacc_sql.y`

#### IN/NOT IN è¯­æ³• (line 800-850)

```yacc
expression:
    // IN (value_list) è¡¨è¾¾å¼
    | expression IN LBRACE expression_list RBRACE {
      vector<unique_ptr<Expression>> value_list;
      if ($4 != nullptr) {
        value_list = std::move(*$4);
        delete $4;
      }
      $$ = new InExpr(false, unique_ptr<Expression>($1), std::move(value_list));
      $$->set_name(token_name(sql_string, &@$));
    }
    // NOT IN (value_list) è¡¨è¾¾å¼
    | expression NOT IN LBRACE expression_list RBRACE {
      vector<unique_ptr<Expression>> value_list;
      if ($5 != nullptr) {
        value_list = std::move(*$5);
        delete $5;
      }
      $$ = new InExpr(true, unique_ptr<Expression>($1), std::move(value_list));
      $$->set_name(token_name(sql_string, &@$));
    }
    // IN (subquery) è¡¨è¾¾å¼
    | expression IN LBRACE select_stmt RBRACE {
      $$ = new InExpr(false, unique_ptr<Expression>($1), unique_ptr<Expression>(new SubqueryExpr(unique_ptr<SelectSqlNode>($4))));
      $$->set_name(token_name(sql_string, &@$));
    }
    // NOT IN (subquery) è¡¨è¾¾å¼
    | expression NOT IN LBRACE select_stmt RBRACE {
      $$ = new InExpr(true, unique_ptr<Expression>($1), unique_ptr<Expression>(new SubqueryExpr(unique_ptr<SelectSqlNode>($5))));
      $$->set_name(token_name(sql_string, &@$));
    }
```

#### EXISTS/NOT EXISTS è¯­æ³• (line 850-870)

```yacc
expression:
    // EXISTS è¡¨è¾¾å¼
    | EXISTS LBRACE select_stmt RBRACE {
      $$ = new ExistsExpr(false, unique_ptr<Expression>(new SubqueryExpr(unique_ptr<SelectSqlNode>($3))));
      $$->set_name(token_name(sql_string, &@$));
    }
    // NOT EXISTS è¡¨è¾¾å¼
    | NOT EXISTS LBRACE select_stmt RBRACE {
      $$ = new ExistsExpr(true, unique_ptr<Expression>(new SubqueryExpr(unique_ptr<SelectSqlNode>($4))));
      $$->set_name(token_name(sql_string, &@$));
    }
```

---

## 4. è¡¨è¾¾å¼å±‚å®ç°

### 4.1 InExpr æ ¸å¿ƒå®ç°

**æ–‡ä»¶**: `src/observer/sql/expr/expression.cpp`

#### æ„é€ å‡½æ•° (line 1420-1440)

```cpp
// IN (subquery) æ„é€ å‡½æ•° - ä¿ç•™åŸæœ‰åŠŸèƒ½
InExpr::InExpr(bool is_not, std::unique_ptr<Expression> left, std::unique_ptr<Expression> subquery)
    : is_not_(is_not), left_(std::move(left)), subquery_(std::move(subquery)), is_subquery_(true)
{}

// IN (value_list) æ„é€ å‡½æ•° - æ–°å¢åŠŸèƒ½
InExpr::InExpr(bool is_not, std::unique_ptr<Expression> left, std::vector<std::unique_ptr<Expression>> &&value_list)
    : is_not_(is_not), left_(std::move(left)), value_list_(std::move(value_list)), is_subquery_(false)
{}
```

#### get_value æ ¸å¿ƒé€»è¾‘ (line 1450-1550)

```cpp
RC InExpr::get_value(const Tuple &tuple, Value &value) const
{
  // 1. è®¡ç®—å·¦ä¾§è¡¨è¾¾å¼çš„å€¼
  Value left_value;
  RC rc = left_->get_value(tuple, left_value);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  bool found = false;
  bool has_null = false;

  if (is_subquery_) {
    // å­æŸ¥è¯¢å½¢å¼ï¼šæ‰§è¡Œå­æŸ¥è¯¢è·å–ç»“æœ
    std::vector<Value> subquery_results;
    
    // è·å–å­æŸ¥è¯¢çš„ SelectSqlNode
    if (subquery_->type() != ExprType::SUBQUERY) {
      return RC::INVALID_ARGUMENT;
    }
    
    SubqueryExpr *subquery_expr = static_cast<SubqueryExpr *>(subquery_.get());
    const SelectSqlNode *select_node = subquery_expr->get_select_node();
    
    // æ‰§è¡Œå­æŸ¥è¯¢ï¼Œcheck_single_column=trueï¼ˆINè¦æ±‚å•åˆ—ï¼‰
    static SubqueryExecutor executor;
    rc = executor.execute_subquery(select_node, session_, subquery_results, true);
    if (rc != RC::SUCCESS) {
      return rc;
    }
    
    // åœ¨å­æŸ¥è¯¢ç»“æœä¸­æŸ¥æ‰¾åŒ¹é…å€¼
    for (const Value &sub_value : subquery_results) {
      if (sub_value.is_null()) {
        has_null = true;
        continue;
      }
      
      int cmp = left_value.compare(sub_value);
      if (cmp == 0) {
        found = true;
        break;
      }
    }
  } else {
    // å€¼åˆ—è¡¨å½¢å¼ï¼šé€ä¸ªæ¯”è¾ƒ
    for (const auto &expr : value_list_) {
      Value list_value;
      rc = expr->get_value(tuple, list_value);
      if (rc != RC::SUCCESS) {
        return rc;
      }
      
      if (list_value.is_null()) {
        has_null = true;
        continue;
      }
      
      int cmp = left_value.compare(list_value);
      if (cmp == 0) {
        found = true;
        break;
      }
    }
  }
  
  // 2. æ ¹æ®SQLæ ‡å‡†å¤„ç†ç»“æœ
  bool result;
  if (is_not_) {
    // NOT IN è¯­ä¹‰
    if (found) {
      result = false;  // æ‰¾åˆ°åŒ¹é…ï¼ŒNOT IN ä¸º false
    } else if (has_null) {
      result = false;  // æœ‰NULLä¸”æœªæ‰¾åˆ°åŒ¹é…ï¼ŒNOT IN ä¸º falseï¼ˆSQLæ ‡å‡†ï¼‰
    } else {
      result = true;   // æ— NULLä¸”æœªæ‰¾åˆ°åŒ¹é…ï¼ŒNOT IN ä¸º true
    }
  } else {
    // IN è¯­ä¹‰
    if (found) {
      result = true;   // æ‰¾åˆ°åŒ¹é…ï¼ŒIN ä¸º true
    } else {
      result = false;  // æœªæ‰¾åˆ°åŒ¹é…ï¼ŒIN ä¸º falseï¼ˆNULLè¢«å¿½ç•¥ï¼‰
    }
  }
  
  value.set_boolean(result);
  return RC::SUCCESS;
}
```

### 4.2 ExistsExpr æ ¸å¿ƒå®ç°

**æ–‡ä»¶**: `src/observer/sql/expr/expression.cpp` (line 1560-1620)

```cpp
RC ExistsExpr::get_value(const Tuple &tuple, Value &value) const
{
  if (subquery_->type() != ExprType::SUBQUERY) {
    return RC::INVALID_ARGUMENT;
  }
  
  SubqueryExpr *subquery_expr = static_cast<SubqueryExpr *>(subquery_.get());
  const SelectSqlNode *select_node = subquery_expr->get_select_node();
  
  // æ‰§è¡Œå­æŸ¥è¯¢ï¼Œcheck_single_column=falseï¼ˆEXISTSå…è®¸å¤šåˆ—ï¼‰
  std::vector<Value> results;
  static SubqueryExecutor executor;
  RC rc = executor.execute_subquery(select_node, session_, results, false);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  // EXISTS åªå…³å¿ƒæ˜¯å¦æœ‰ç»“æœï¼Œä¸å…³å¿ƒå…·ä½“å€¼
  bool has_results = !results.empty();
  bool result = is_not_ ? !has_results : has_results;
  
  value.set_boolean(result);
  return RC::SUCCESS;
}
```

---

## 5. å­æŸ¥è¯¢æ‰§è¡Œå™¨å®ç°

### 5.1 SubqueryExecutor æ ¸å¿ƒæ¶æ„

**æ–‡ä»¶**: `src/observer/sql/expr/subquery_executor.cpp`

#### ä¸»å…¥å£å‡½æ•° (line 30-80)

```cpp
RC SubqueryExecutor::execute_subquery(const SelectSqlNode *select_node, 
                                      Session *session, 
                                      std::vector<Value> &results, 
                                      bool check_single_column)
{
  results.clear();
  
  // 1. å‚æ•°éªŒè¯
  if (!select_node || !session) {
    return RC::INVALID_ARGUMENT;
  }
  
  // 2. æ£€æŸ¥å­æŸ¥è¯¢åˆ—æ•°ï¼ˆé’ˆå¯¹ IN å’Œæ ‡é‡å­æŸ¥è¯¢ï¼‰
  if (check_single_column && select_node->expressions.size() != 1) {
    LOG_WARN("Subquery must return exactly one column, but got %zu columns", 
             select_node->expressions.size());
    return RC::SQL_SYNTAX;
  }
  
  // 3. é€‰æ‹©æ‰§è¡Œç­–ç•¥
  if (is_simple_subquery(select_node)) {
    return execute_simple_subquery(select_node, session, results, check_single_column);
  } else {
    return execute_complex_subquery(select_node, session, results, check_single_column);
  }
}
```

#### ç®€å•å­æŸ¥è¯¢æ‰§è¡Œ (line 100-200)

```cpp
RC SubqueryExecutor::execute_simple_subquery(const SelectSqlNode *select_node, 
                                             Session *session, 
                                             std::vector<Value> &results, 
                                             bool check_single_column)
{
  // 1. è·å–è¡¨å’Œå­—æ®µä¿¡æ¯
  Db *db = session->get_current_db();
  Table *table = db->find_table(select_node->relations.front().c_str());
  if (!table) {
    return RC::SCHEMA_TABLE_NOT_EXIST;
  }
  
  // 2. åˆ›å»ºæ‰«æç®—å­
  TableScanPhysicalOperator scan_op(table);
  RC rc = scan_op.open(nullptr);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  // 3. å¤„ç† SELECT * çš„ç‰¹æ®Šæƒ…å†µ
  if (select_node->expressions.front()->type() == ExprType::STAR) {
    // è·å–ç¬¬ä¸€ä¸ªtupleä»¥æ£€æŸ¥åˆ—æ•°
    Tuple *tuple = nullptr;
    rc = scan_op.next(tuple);
    if (rc == RC::SUCCESS && tuple) {
      if (check_single_column && tuple->cell_num() != 1) {
        LOG_WARN("Subquery with SELECT * returns %d columns, but must return exactly 1", 
                 tuple->cell_num());
        scan_op.close();
        return RC::SQL_SYNTAX;  // å¤šåˆ—æ—¶è¿”å›è¯­æ³•é”™è¯¯
      }
      
      int cells_to_collect = check_single_column ? 1 : tuple->cell_num();
      
      // æ”¶é›†ç¬¬ä¸€è¡Œæ•°æ®
      do {
        for (int i = 0; i < cells_to_collect; i++) {
          Value cell_value;
          tuple->cell_at(i, cell_value);
          results.push_back(cell_value);
        }
        rc = scan_op.next(tuple);
      } while (rc == RC::SUCCESS && tuple);
    }
  } else {
    // å¤„ç†æ™®é€šè¡¨è¾¾å¼
    // ... ç±»ä¼¼é€»è¾‘å¤„ç†å…·ä½“å­—æ®µ ...
  }
  
  scan_op.close();
  return RC::SUCCESS;
}
```

#### å¤æ‚å­æŸ¥è¯¢æ‰§è¡Œ (line 250-350)

```cpp
RC SubqueryExecutor::execute_complex_subquery(const SelectSqlNode *select_node, 
                                              Session *session, 
                                              std::vector<Value> &results, 
                                              bool check_single_column)
{
  // 1. ä½¿ç”¨å®Œæ•´çš„æŸ¥è¯¢å¼•æ“
  SelectStmt select_stmt;
  RC rc = select_stmt.create(session->get_current_db(), *select_node, session);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  // 2. ç”Ÿæˆç‰©ç†è®¡åˆ’
  PhysicalPlanGenerator physical_generator;
  std::unique_ptr<PhysicalOperator> physical_oper;
  rc = physical_generator.create(select_stmt, physical_oper);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  // 3. æ‰§è¡Œå¹¶æ”¶é›†ç»“æœ
  rc = physical_oper->open(nullptr);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  Tuple *tuple = nullptr;
  rc = physical_oper->next(tuple);
  
  if (rc == RC::SUCCESS && tuple) {
    int tuple_cell_num = tuple->cell_num();
    
    // æ£€æŸ¥åˆ—æ•°
    if (check_single_column && tuple_cell_num != 1) {
      LOG_WARN("Subquery returns %d columns, but must return exactly 1", tuple_cell_num);
      physical_oper->close();
      return RC::SQL_SYNTAX;
    }
    
    int cells_to_collect = check_single_column ? 1 : tuple_cell_num;
    
    // æ”¶é›†æ‰€æœ‰ç»“æœ
    do {
      for (int i = 0; i < cells_to_collect; i++) {
        Value cell_value;
        tuple->cell_at(i, cell_value);
        results.push_back(cell_value);
      }
      rc = physical_oper->next(tuple);
    } while (rc == RC::SUCCESS && tuple);
  }
  
  physical_oper->close();
  return RC::SUCCESS;
}
```

---

## 6. å…³é”®ç‰¹æ€§è¯¦è§£

### 6.1 å¤šåˆ—æ£€æŸ¥æœºåˆ¶

#### é—®é¢˜æè¿°
```sql
-- âŒ é”™è¯¯ï¼šINå­æŸ¥è¯¢è¿”å›å¤šåˆ—
SELECT * FROM t1 WHERE col1 IN (SELECT * FROM t2);  -- t2æœ‰å¤šåˆ—

-- âŒ é”™è¯¯ï¼šæ ‡é‡å­æŸ¥è¯¢è¿”å›å¤šåˆ—  
SELECT * FROM t1 WHERE col1 = (SELECT * FROM t2 WHERE id = 1);
```

#### è§£å†³æ–¹æ¡ˆ
```cpp
// åœ¨ execute_subquery å…¥å£å¤„æ£€æŸ¥
if (check_single_column && select_node->expressions.size() != 1) {
  return RC::SQL_SYNTAX;  // è½¬æ¢ä¸º FAILURE è¾“å‡º
}

// åœ¨è¿è¡Œæ—¶æ£€æŸ¥å®é™…è¿”å›çš„åˆ—æ•°
if (check_single_column && tuple->cell_num() != 1) {
  return RC::SQL_SYNTAX;  // SELECT * å±•å¼€åçš„åˆ—æ•°æ£€æŸ¥
}
```

### 6.2 NULLå€¼å¤„ç†é€»è¾‘

#### NOT IN ä¸ NULL çš„ç‰¹æ®Šæ€§
```sql
-- ç¤ºä¾‹æ•°æ®ï¼št2.col2 = [1, 2, NULL]
SELECT * FROM t1 WHERE id NOT IN (SELECT col2 FROM t2);
-- ç»“æœï¼šç©ºé›†ï¼ˆå› ä¸ºåŒ…å«NULLï¼‰
```

#### å®ç°é€»è¾‘
```cpp
// NOT IN è¯­ä¹‰å®ç°
if (is_not_) {
  if (found) {
    result = false;      // æ‰¾åˆ°åŒ¹é…ï¼šNOT IN ä¸º false
  } else if (has_null) {
    result = false;      // æœ‰NULLä¸”æœªåŒ¹é…ï¼šNOT IN ä¸º false (SQLæ ‡å‡†)
  } else {
    result = true;       // æ— NULLä¸”æœªåŒ¹é…ï¼šNOT IN ä¸º true
  }
}
```

### 6.3 é”™è¯¯å¤„ç†ä¸FAILUREè¾“å‡º

#### parse_stage.cpp ä¿®æ”¹ (line 180-190)
```cpp
if (sql_node->flag == SCF_ERROR) {
  rc = RC::SQL_SYNTAX;
  sql_result->set_return_code(rc);
  sql_result->set_state_string("");  // è®¾ç½®ä¸ºç©ºï¼Œç¡®ä¿è¾“å‡º FAILURE
  return rc;
}
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 ç»“æœç¼“å­˜æœºåˆ¶

```cpp
class SubqueryExecutor 
{
private:
  std::unordered_map<std::string, std::vector<Value>> cache_;
  
  std::string generate_cache_key(const SelectSqlNode *select_node) {
    // åŸºäºå­æŸ¥è¯¢å†…å®¹ç”Ÿæˆå”¯ä¸€é”®
    return "subquery_" + std::to_string(reinterpret_cast<uintptr_t>(select_node));
  }
};
```

### 7.2 æ™ºèƒ½æ‰§è¡Œç­–ç•¥

```cpp
bool SubqueryExecutor::is_simple_subquery(const SelectSqlNode *select_node)
{
  // ç®€å•å­æŸ¥è¯¢ï¼šå•è¡¨ã€æ— JOINã€æ— å¤æ‚æ¡ä»¶
  return select_node->relations.size() == 1 &&
         select_node->join_tables.empty() &&
         select_node->group_by.empty() &&
         select_node->having_conditions.empty();
}
```

---

## 8. æ”¯æŒçš„åŠŸèƒ½çŸ©é˜µ

### 8.1 IN/NOT IN æ”¯æŒ

| åŠŸèƒ½ | è¯­æ³•ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|---------|---------|
| å€¼åˆ—è¡¨ | `WHERE id IN (1,2,3)` | âœ… å®Œæ•´æ”¯æŒ |
| å­æŸ¥è¯¢ | `WHERE id IN (SELECT ...)` | âœ… å®Œæ•´æ”¯æŒ |
| NOT IN å€¼åˆ—è¡¨ | `WHERE id NOT IN (1,2,3)` | âœ… å®Œæ•´æ”¯æŒ |
| NOT IN å­æŸ¥è¯¢ | `WHERE id NOT IN (SELECT ...)` | âœ… å®Œæ•´æ”¯æŒ |
| NULLå¤„ç† | `NOT IN (1, NULL, 3)` | âœ… SQLæ ‡å‡† |

### 8.2 EXISTS/NOT EXISTS æ”¯æŒ

| åŠŸèƒ½ | è¯­æ³•ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|---------|---------|
| EXISTS | `WHERE EXISTS (SELECT ...)` | âœ… å®Œæ•´æ”¯æŒ |
| NOT EXISTS | `WHERE NOT EXISTS (SELECT ...)` | âœ… å®Œæ•´æ”¯æŒ |
| å¤šåˆ—å…è®¸ | `WHERE EXISTS (SELECT *)` | âœ… å®Œæ•´æ”¯æŒ |

### 8.3 æ ‡é‡å­æŸ¥è¯¢æ”¯æŒ

| åŠŸèƒ½ | è¯­æ³•ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|---------|---------|
| ç­‰äºæ¯”è¾ƒ | `WHERE col = (SELECT ...)` | âœ… å®Œæ•´æ”¯æŒ |
| å¤§å°æ¯”è¾ƒ | `WHERE col > (SELECT ...)` | âœ… å®Œæ•´æ”¯æŒ |
| èšåˆå‡½æ•° | `WHERE col = (SELECT MAX(...))` | âœ… å®Œæ•´æ”¯æŒ |
| å¤šåˆ—æ£€æŸ¥ | `WHERE col = (SELECT *)` | âœ… è¿”å›FAILURE |

### 8.4 èšåˆå‡½æ•°æ”¯æŒ

| å‡½æ•° | ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|-----|---------|
| COUNT | `(SELECT COUNT(*) FROM ...)` | âœ… å®Œæ•´æ”¯æŒ |
| SUM | `(SELECT SUM(col) FROM ...)` | âœ… å®Œæ•´æ”¯æŒ |
| AVG | `(SELECT AVG(col) FROM ...)` | âœ… å®Œæ•´æ”¯æŒ |
| MAX | `(SELECT MAX(col) FROM ...)` | âœ… å®Œæ•´æ”¯æŒ |
| MIN | `(SELECT MIN(col) FROM ...)` | âœ… å®Œæ•´æ”¯æŒ |

---

## 9. æŠ€æœ¯ç»†èŠ‚

### 9.1 å†…å­˜ç®¡ç†

```cpp
// æ™ºèƒ½æŒ‡é’ˆç®¡ç†é¿å…å†…å­˜æ³„æ¼
class InExpr : public Expression {
private:
  std::unique_ptr<Expression>              left_;        
  std::unique_ptr<Expression>              subquery_;    
  std::vector<std::unique_ptr<Expression>> value_list_;  
};
```

### 9.2 ç±»å‹ç³»ç»Ÿé›†æˆ

```cpp
// å¤ç”¨ç°æœ‰çš„ Value::compare è¿›è¡Œç±»å‹è½¬æ¢
int cmp = left_value.compare(sub_value);  // è‡ªåŠ¨å¤„ç†ç±»å‹è½¬æ¢
```

### 9.3 é”™è¯¯ä¼ æ’­é“¾

```
SubqueryExecutor::execute_subquery (RC::SQL_SYNTAX)
    â†“
InExpr::get_value (ä¼ æ’­é”™è¯¯)
    â†“  
PredicatePhysicalOperator::next (ä¼ æ’­é”™è¯¯)
    â†“
plain_communicator.cpp (è¾“å‡ºFAILURE)
```

---

## 10. æµ‹è¯•éªŒè¯

### 10.1 æ ¸å¿ƒæµ‹è¯•ç”¨ä¾‹

```sql
-- åŸºç¡€åŠŸèƒ½æµ‹è¯•
SELECT * FROM t1 WHERE id IN (1, 2, 3);
SELECT * FROM t1 WHERE id IN (SELECT id FROM t2);
SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2);

-- é”™è¯¯æƒ…å†µæµ‹è¯•
SELECT * FROM t1 WHERE id IN (SELECT * FROM t2);  -- FAILURE (å¤šåˆ—)
SELECT * FROM t1 WHERE id = (SELECT * FROM t2);   -- FAILURE (å¤šåˆ—)

-- NULLå¤„ç†æµ‹è¯•
SELECT * FROM t1 WHERE id NOT IN (SELECT col FROM t2);  -- åŒ…å«NULLæ—¶è¿”å›ç©ºé›†

-- èšåˆå‡½æ•°æµ‹è¯•
SELECT * FROM t1 WHERE val > (SELECT AVG(score) FROM t2);
```

### 10.2 æ€§èƒ½æµ‹è¯•

```sql
-- å¤§æ•°æ®é‡æµ‹è¯•ï¼ˆ1000+è¡Œï¼‰
SELECT * FROM large_t1 WHERE id IN (SELECT id FROM large_t2);

-- å¤æ‚åµŒå¥—æµ‹è¯•
SELECT * FROM t1 WHERE id IN (
  SELECT ref_id FROM t2 WHERE score > (SELECT AVG(score) FROM t2)
);
```

---

## 11. å·²çŸ¥é™åˆ¶

### 11.1 å½“å‰ä¸æ”¯æŒçš„åŠŸèƒ½

- âŒ **å…³è”å­æŸ¥è¯¢**: `WHERE EXISTS (SELECT * FROM t2 WHERE t2.id = t1.id)`
- âŒ **ALL/ANY/SOME**: `WHERE col > ALL (SELECT ...)`  
- âŒ **å¤šå±‚åµŒå¥—**: è¶…è¿‡2å±‚çš„åµŒå¥—å­æŸ¥è¯¢
- âŒ **å­æŸ¥è¯¢ä¼˜åŒ–**: å¤æ‚çš„æŸ¥è¯¢é‡å†™å’Œä¼˜åŒ–

### 11.2 æ€§èƒ½è€ƒè™‘

- ğŸ“Š **é‡å¤æ‰§è¡Œ**: åŒä¸€å­æŸ¥è¯¢å¯èƒ½è¢«é‡å¤æ‰§è¡Œï¼ˆç¼“å­˜éƒ¨åˆ†ç¼“è§£ï¼‰
- ğŸ“Š **å†…å­˜å ç”¨**: å¤§ç»“æœé›†å®Œå…¨åŠ è½½åˆ°å†…å­˜
- ğŸ“Š **ç´¢å¼•ä½¿ç”¨**: å­æŸ¥è¯¢æ‰§è¡Œä¸æ€»æ˜¯èƒ½åˆ©ç”¨ç´¢å¼•

---

## 12. æ€»ç»“

### 12.1 å®ç°å®Œæ•´æ€§

MiniOB ç®€å•å­æŸ¥è¯¢åŠŸèƒ½å·²è¾¾åˆ°ç”Ÿäº§çº§åˆ«ï¼š

- âœ… **åŠŸèƒ½å®Œæ•´**: è¦†ç›–IN/NOT INã€EXISTS/NOT EXISTSã€æ ‡é‡å­æŸ¥è¯¢
- âœ… **è¯­æ³•æ ‡å‡†**: å®Œå…¨ç¬¦åˆSQLæ ‡å‡†è¯­æ³•
- âœ… **é”™è¯¯å¤„ç†**: ä¸¥æ ¼çš„é”™è¯¯æ£€æµ‹å’Œç”¨æˆ·å‹å¥½çš„é”™è¯¯è¾“å‡º
- âœ… **NULLè¯­ä¹‰**: å®Œæ•´çš„SQLä¸‰å€¼é€»è¾‘æ”¯æŒ
- âœ… **æ€§èƒ½ä¼˜åŒ–**: ç»“æœç¼“å­˜å’Œæ™ºèƒ½æ‰§è¡Œç­–ç•¥
- âœ… **æµ‹è¯•è¦†ç›–**: å…¨é¢çš„åŠŸèƒ½å’Œè¾¹ç•Œæµ‹è¯•

### 12.2 ä»£ç è´¨é‡

- ğŸ“ **æ¶æ„æ¸…æ™°**: åˆ†å±‚è®¾è®¡ï¼ŒèŒè´£æ˜ç¡®
- ğŸ”§ **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„å­æŸ¥è¯¢åŠŸèƒ½
- ğŸ›¡ï¸ **å¥å£®æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ£€æŸ¥
- ğŸ“š **å¯ç»´æŠ¤æ€§**: è‰¯å¥½çš„ä»£ç æ³¨é‡Šå’Œæ–‡æ¡£

### 12.3 ä¸‹ä¸€æ­¥å‘å±•

ä¼˜å…ˆçº§å»ºè®®ï¼š
1. **å…³è”å­æŸ¥è¯¢**: æ”¯æŒå¤–å±‚è¡¨å¼•ç”¨
2. **æŸ¥è¯¢ä¼˜åŒ–**: å­æŸ¥è¯¢è½¬æ¢ä¸ºJOIN
3. **æ€§èƒ½æå‡**: æµå¼å¤„ç†å¤§ç»“æœé›†
4. **æ‰©å±•åŠŸèƒ½**: ALL/ANY/SOME è¿ç®—ç¬¦

---

**æ–‡æ¡£ç»´æŠ¤**: AI Assistant  
**æœ€åæ›´æ–°**: 2025-10-16  
**ç‰ˆæœ¬**: v1.0  
**çŠ¶æ€**: âœ… å®Œæ•´å½’æ¡£

**ç›¸å…³æ–‡æ¡£**: 
- [ç®€å•å­æŸ¥è¯¢æµ‹è¯•æ–‡æ¡£](./ç®€å•å­æŸ¥è¯¢æµ‹è¯•æ–‡æ¡£.md)
- [åŸå§‹è®¾è®¡æ–‡æ¡£](./no_use_docs/å­æŸ¥è¯¢åŠŸèƒ½è®¾è®¡æ–‡æ¡£.md)

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·å‚è€ƒæµ‹è¯•æ–‡æ¡£è¿›è¡ŒéªŒè¯å’Œè°ƒè¯•ã€‚

åŠŸèƒ½å·²å®Œæ•´å®ç°å¹¶æŠ•å…¥ä½¿ç”¨ï¼ğŸš€
