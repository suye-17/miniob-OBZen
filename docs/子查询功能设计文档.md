# MiniOB 子查询功能设计文档

## 1. 概述

本文档描述了为 MiniOB 数据库添加简单子查询功能的详细设计方案。该功能将支持基本的子查询操作，包括 IN/NOT IN、EXISTS/NOT EXISTS 以及与子查询结果的比较运算，同时支持子查询中的聚合函数。

### 1.1 功能范围

- **IN/NOT IN 语句**：支持简单的 IN 和 NOT IN 操作，包括对 NULL 值的特殊处理
- **EXISTS/NOT EXISTS 语句**：支持存在性检查
- **比较运算符**：支持与子查询结果进行比较运算（=、<、>、<=、>=、<>）
- **聚合函数支持**：子查询中可以包含聚合函数（COUNT、SUM、AVG、MAX、MIN）
- **类型转换**：支持不同类型值之间的比较
- **非关联子查询**：子查询独立于主查询，不涉及关联

### 1.2 不支持的功能

- 关联子查询（子查询中引用主查询的字段）
- 嵌套子查询（子查询中包含子查询）
- ALL/ANY/SOME 运算符

## 2. 当前架构分析

### 2.1 SQL 执行流程

根据现有的 SQL 执行流程文档，MiniOB 的执行流程如下：

```
用户输入SQL字符串
    ↓
词法分析 (lex_sql.l)
    ↓
语法分析 (yacc_sql.y)
    ↓
生成语法树 (ParsedSqlNode)
    ↓
语义解析 (Resolver)
    ↓
转换为内部结构 (Statement)
    ↓
查询优化 (Optimizer)
    ↓
生成逻辑算子 (LogicalOperator)
    ↓
生成物理算子 (PhysicalOperator)
    ↓
执行引擎 (Executor)
    ↓
火山模型执行
    ↓
返回结果集 (SqlResult)
```

#### 子查询扩展执行流程

```
主查询解析
    ↓
发现子查询表达式
    ↓
递归解析子查询
    ↓
生成子查询执行计划
    ↓
主查询执行过程中调用子查询
    ↓
子查询结果缓存
    ↓
子查询结果参与主查询条件判断
    ↓
返回最终结果
```

### 2.2 现有表达式系统

当前 MiniOB 支持以下表达式类型：
- `FieldExpr`: 字段表达式
- `ValueExpr`: 常量值表达式
- `ComparisonExpr`: 比较表达式（支持 =、<、>、<=、>=、<>、LIKE、NOT LIKE）
- `ConjunctionExpr`: 联结表达式（AND、OR）
- `ArithmeticExpr`: 算术表达式
- `AggregateExpr`: 聚合表达式

### 2.3 现有比较运算符

```cpp
enum CompOp {
  EQUAL_TO,     ///< "="
  LESS_EQUAL,   ///< "<="
  NOT_EQUAL,    ///< "<>"
  LESS_THAN,    ///< "<"
  GREAT_EQUAL,  ///< ">="
  GREAT_THAN,   ///< ">"
  LIKE_OP,      ///< "LIKE"
  NOT_LIKE_OP,  ///< "NOT LIKE"
  NO_OP
};
```

## 3. 子查询功能设计

### 3.1 语法扩展

#### 3.1.1 新增比较运算符

需要在 `CompOp` 枚举中添加新的运算符：

```cpp
enum CompOp {
  // 现有运算符...
  IN_OP,        ///< "IN"
  NOT_IN_OP,    ///< "NOT IN"
  EXISTS_OP,    ///< "EXISTS"
  NOT_EXISTS_OP ///< "NOT EXISTS"
};
```

#### 3.1.2 词法分析扩展

在 `lex_sql.l` 中添加新的关键字：

```lex
IN                                      RETURN_TOKEN(IN);
EXISTS                                  RETURN_TOKEN(EXISTS);
```

#### 3.1.3 语法分析扩展

在 `yacc_sql.y` 中添加新的语法规则：

```yacc
%token IN EXISTS

// 扩展比较运算符
comp_op:
    EQ { $$ = EQUAL_TO; }
    | LT { $$ = LESS_THAN; }
    | GT { $$ = GREAT_THAN; }
    | LE { $$ = LESS_EQUAL; }
    | GE { $$ = GREAT_EQUAL; }
    | NE { $$ = NOT_EQUAL; }
    | LIKE { $$ = LIKE_OP; }
    | NOT LIKE { $$ = NOT_LIKE_OP; }
    | IN { $$ = IN_OP; }
    | NOT IN { $$ = NOT_IN_OP; }
    ;

// 子查询表达式
subquery_expr:
    LBRACE select_stmt RBRACE
    {
      $$ = new SubqueryExpr($2);
    }
    ;

// 扩展条件表达式以支持子查询
condition:
    expression comp_op expression
    {
      $$ = new ConditionSqlNode();
      // 设置条件...
    }
    | expression IN subquery_expr
    {
      $$ = new ConditionSqlNode();
      $$->comp = IN_OP;
      // 设置左表达式和子查询...
    }
    | expression NOT IN subquery_expr
    {
      $$ = new ConditionSqlNode();
      $$->comp = NOT_IN_OP;
      // 设置左表达式和子查询...
    }
    | EXISTS subquery_expr
    {
      $$ = new ConditionSqlNode();
      $$->comp = EXISTS_OP;
      // 设置子查询...
    }
    | NOT EXISTS subquery_expr
    {
      $$ = new ConditionSqlNode();
      $$->comp = NOT_EXISTS_OP;
      // 设置子查询...
    }
    ;
```

### 3.2 AST 节点设计

#### 3.2.1 子查询表达式

新增 `SubqueryExpr` 类：

```cpp
/**
 * @brief 子查询表达式
 * @ingroup Expression
 */
class SubqueryExpr : public Expression
{
public:
  SubqueryExpr(SelectStmt *subquery_stmt);
  virtual ~SubqueryExpr();

  ExprType type() const override { return ExprType::SUBQUERY; }
  AttrType value_type() const override;
  
  RC get_value(const Tuple &tuple, Value &value) const override;
  RC get_values(const Tuple &tuple, std::vector<Value> &values) const override;
  
  unique_ptr<Expression> copy() const override;
  
  SelectStmt *subquery_stmt() const { return subquery_stmt_; }
  
  // 判断子查询是否返回多行
  bool is_multi_row() const;
  
  // 执行子查询并返回结果
  RC execute_subquery(std::vector<Value> &results) const;

private:
  SelectStmt *subquery_stmt_;
  mutable std::vector<Value> cached_results_;
  mutable bool results_cached_ = false;
};
```

#### 3.2.2 扩展比较表达式

扩展现有的 `ComparisonExpr` 以支持子查询：

```cpp
class ComparisonExpr : public Expression
{
public:
  // 现有构造函数...
  
  // 新增：支持子查询的构造函数
  ComparisonExpr(CompOp comp, unique_ptr<Expression> left, unique_ptr<SubqueryExpr> right);
  
  // 新增：处理子查询比较的方法
  RC compare_with_subquery(const Value &left_value, const std::vector<Value> &subquery_results, bool &result) const;
  
  // 新增：处理 IN/NOT IN 操作
  RC handle_in_operation(const Value &left_value, const std::vector<Value> &subquery_results, bool &result) const;
  
  // 新增：处理 EXISTS/NOT EXISTS 操作
  RC handle_exists_operation(const std::vector<Value> &subquery_results, bool &result) const;

private:
  // 现有成员...
  unique_ptr<SubqueryExpr> subquery_right_; // 右侧子查询表达式
};
```

#### 3.2.3 扩展 ConditionSqlNode

```cpp
struct ConditionSqlNode
{
  // 现有成员...
  
  // 新增：子查询支持
  SubqueryExpr *subquery = nullptr;  ///< 子查询表达式
  bool left_has_subquery = false;    ///< 左侧是否包含子查询
  bool right_has_subquery = false;   ///< 右侧是否包含子查询
};
```

### 3.3 表达式类型扩展

在 `ExprType` 枚举中添加新类型：

```cpp
enum class ExprType
{
  // 现有类型...
  SUBQUERY,     ///< 子查询表达式
};
```

### 3.4 执行计划设计

#### 3.4.1 逻辑算子

新增 `SubqueryLogicalOperator`：

```cpp
/**
 * @brief 子查询逻辑算子
 */
class SubqueryLogicalOperator : public LogicalOperator
{
public:
  SubqueryLogicalOperator(SelectStmt *subquery_stmt);
  virtual ~SubqueryLogicalOperator() = default;

  LogicalOperatorType type() const override { return LogicalOperatorType::SUBQUERY; }

  RC generate_children_logical_operators(std::vector<std::unique_ptr<LogicalOperator>> &child_opers) override;

  SelectStmt *subquery_stmt() const { return subquery_stmt_; }

private:
  SelectStmt *subquery_stmt_;
};
```

#### 3.4.2 物理算子

新增 `SubqueryPhysicalOperator`：

```cpp
/**
 * @brief 子查询物理算子
 */
class SubqueryPhysicalOperator : public PhysicalOperator
{
public:
  SubqueryPhysicalOperator(std::unique_ptr<PhysicalOperator> child_oper);
  virtual ~SubqueryPhysicalOperator() = default;

  PhysicalOperatorType type() const override { return PhysicalOperatorType::SUBQUERY; }

  RC open(Trx *trx) override;
  RC next() override;
  RC close() override;

  Tuple *current_tuple() override;

  // 执行子查询并返回所有结果
  RC execute_subquery(std::vector<Value> &results);

private:
  std::vector<Value> subquery_results_;
  bool executed_ = false;
};
```

### 3.5 求值逻辑设计

#### 3.5.1 IN/NOT IN 操作

```cpp
RC ComparisonExpr::handle_in_operation(const Value &left_value, 
                                     const std::vector<Value> &subquery_results, 
                                     bool &result) const
{
  result = false;
  bool has_null = false;
  
  for (const Value &subquery_value : subquery_results) {
    if (subquery_value.is_null()) {
      has_null = true;
      continue;
    }
    
    if (left_value.is_null()) {
      // NULL IN (...) 总是返回 NULL（false）
      result = false;
      return RC::SUCCESS;
    }
    
    int cmp_result = left_value.compare(subquery_value);
    if (cmp_result == 0) {
      result = (comp_ == IN_OP);
      return RC::SUCCESS;
    }
  }
  
  // 如果没有匹配项但有 NULL 值
  if (has_null) {
    // 对于 NOT IN，如果子查询结果中有 NULL，结果为 NULL（false）
    // 对于 IN，如果没有匹配且有 NULL，结果为 NULL（false）
    result = false;
  } else {
    // 没有 NULL 值且没有匹配项
    result = (comp_ == NOT_IN_OP);
  }
  
  return RC::SUCCESS;
}
```

#### 3.5.2 EXISTS/NOT EXISTS 操作

```cpp
RC ComparisonExpr::handle_exists_operation(const std::vector<Value> &subquery_results, 
                                         bool &result) const
{
  // EXISTS: 子查询返回任何行都为 true
  // NOT EXISTS: 子查询不返回行才为 true
  bool has_rows = !subquery_results.empty();
  result = (comp_ == EXISTS_OP) ? has_rows : !has_rows;
  return RC::SUCCESS;
}
```

#### 3.5.3 比较运算符处理

```cpp
RC ComparisonExpr::compare_with_subquery(const Value &left_value, 
                                        const std::vector<Value> &subquery_results, 
                                        bool &result) const
{
  if (subquery_results.empty()) {
    result = false;
    return RC::SUCCESS;
  }
  
  if (subquery_results.size() > 1) {
    LOG_WARN("Subquery returns more than one row for comparison operator");
    return RC::INVALID_ARGUMENT;
  }
  
  const Value &right_value = subquery_results[0];
  return compare_value(left_value, right_value, result);
}
```

### 3.6 类型转换处理

利用现有的类型系统进行自动类型转换：

```cpp
RC SubqueryExpr::handle_type_conversion(const Value &left_value, 
                                      std::vector<Value> &subquery_results) const
{
  AttrType left_type = left_value.attr_type();
  
  for (Value &subquery_value : subquery_results) {
    if (subquery_value.attr_type() != left_type) {
      Value converted_value;
      RC rc = cast_value(subquery_value, left_type, converted_value);
      if (rc != RC::SUCCESS) {
        LOG_WARN("Failed to convert type from %s to %s", 
                attr_type_to_string(subquery_value.attr_type()),
                attr_type_to_string(left_type));
        return rc;
      }
      subquery_value = converted_value;
    }
  }
  
  return RC::SUCCESS;
}
```

## 4. 实现步骤

### 4.1 第一阶段：基础框架

1. **扩展语法分析器**
   - 在 `lex_sql.l` 中添加 IN、EXISTS 关键字
   - 在 `yacc_sql.y` 中添加子查询语法规则
   - 扩展 `CompOp` 枚举

2. **新增 AST 节点**
   - 实现 `SubqueryExpr` 类
   - 扩展 `ConditionSqlNode` 结构
   - 添加 `ExprType::SUBQUERY`

3. **基础测试**
   - 测试语法解析是否正确
   - 验证 AST 节点创建

### 4.2 第二阶段：表达式系统

1. **扩展比较表达式**
   - 修改 `ComparisonExpr` 以支持子查询
   - 实现子查询求值逻辑
   - 处理 NULL 值的特殊情况

2. **实现求值算法**
   - IN/NOT IN 操作的实现
   - EXISTS/NOT EXISTS 操作的实现
   - 比较运算符的子查询处理

3. **类型转换支持**
   - 利用现有类型系统进行转换
   - 处理类型不匹配的情况

### 4.3 第三阶段：执行引擎

1. **逻辑算子**
   - 实现 `SubqueryLogicalOperator`
   - 集成到逻辑计划生成器

2. **物理算子**
   - 实现 `SubqueryPhysicalOperator`
   - 集成到物理计划生成器

3. **优化策略**
   - 子查询结果缓存
   - 简单的优化规则

### 4.4 第四阶段：测试与优化

1. **功能测试**
   - 各种子查询场景的测试
   - NULL 值处理测试
   - 类型转换测试

2. **性能优化**
   - 子查询执行优化
   - 内存使用优化

3. **错误处理**
   - 完善错误信息
   - 异常情况处理

## 5. 示例用法

### 5.1 IN/NOT IN 示例

```sql
-- 基本 IN 操作
SELECT * FROM users WHERE id IN (SELECT user_id FROM orders);

-- NOT IN 操作
SELECT * FROM products WHERE id NOT IN (SELECT product_id FROM order_items);

-- 带聚合函数的子查询
SELECT * FROM employees WHERE salary IN (SELECT MAX(salary) FROM employees GROUP BY department);
```

### 5.2 EXISTS/NOT EXISTS 示例

```sql
-- EXISTS 操作
SELECT * FROM customers WHERE EXISTS (SELECT 1 FROM orders WHERE orders.customer_id = customers.id);

-- NOT EXISTS 操作
SELECT * FROM products WHERE NOT EXISTS (SELECT 1 FROM order_items WHERE order_items.product_id = products.id);
```

### 5.3 比较运算符示例

```sql
-- 等于比较
SELECT * FROM employees WHERE salary = (SELECT AVG(salary) FROM employees);

-- 大于比较
SELECT * FROM products WHERE price > (SELECT MIN(price) FROM products WHERE category = 'electronics');
```

## 6. 测试计划

### 6.1 单元测试

- 子查询表达式创建和求值测试
- 比较运算符扩展测试
- NULL 值处理测试
- 类型转换测试

### 6.2 集成测试

- 完整 SQL 语句解析测试
- 执行引擎集成测试
- 性能测试

### 6.3 边界情况测试

- 空结果集处理
- 多行结果错误处理
- 内存限制测试

## 7. 风险与限制

### 7.1 已知限制

- 不支持关联子查询
- 不支持嵌套子查询
- 子查询结果需要完全加载到内存中

### 7.2 性能考虑

- 大结果集的内存使用
- 子查询重复执行的开销
- 缺乏高级优化策略

### 7.3 兼容性

- 与现有功能的兼容性
- SQL 标准的符合程度

## 8. 详细实现指南

### 8.1 文件修改清单

#### 8.1.1 语法分析相关文件

**src/observer/sql/parser/lex_sql.l**
```lex
// 在关键字部分添加
IN                                      RETURN_TOKEN(IN);
EXISTS                                  RETURN_TOKEN(EXISTS);
```

**src/observer/sql/parser/yacc_sql.y**
```yacc
// 在 token 声明部分添加
%token IN EXISTS

// 在 union 部分添加
%union {
  // 现有类型...
  SubqueryExpr *                         subquery_expr;
}

// 在 type 声明部分添加
%type <subquery_expr> subquery_expr

// 在 comp_op 规则中添加
comp_op:
    // 现有规则...
    | IN { $$ = IN_OP; }
    | NOT IN { $$ = NOT_IN_OP; }
    ;

// 添加子查询表达式规则
subquery_expr:
    LBRACE select_stmt RBRACE
    {
      $$ = new SubqueryExpr(static_cast<SelectStmt*>($2));
    }
    ;
```

**src/observer/sql/parser/parse_defs.h**
```cpp
// 在 CompOp 枚举中添加
enum CompOp {
  // 现有运算符...
  IN_OP,        ///< "IN"
  NOT_IN_OP,    ///< "NOT IN"
  EXISTS_OP,    ///< "EXISTS"
  NOT_EXISTS_OP ///< "NOT EXISTS"
};

// 扩展 ConditionSqlNode
struct ConditionSqlNode {
  // 现有成员...
  SubqueryExpr *subquery = nullptr;     ///< 子查询表达式（用于 IN/EXISTS）
  bool has_subquery = false;            ///< 是否包含子查询
};
```

#### 8.1.2 表达式系统文件

**src/observer/sql/expr/expression.h**
```cpp
// 在 ExprType 枚举中添加
enum class ExprType {
  // 现有类型...
  SUBQUERY,     ///< 子查询表达式
};

// 新增 SubqueryExpr 类声明
class SubqueryExpr : public Expression {
  // 类定义如前所述...
};

// 扩展 ComparisonExpr 类
class ComparisonExpr : public Expression {
public:
  // 现有成员...
  
  // 新增：处理子查询的构造函数
  ComparisonExpr(CompOp comp, unique_ptr<Expression> left, unique_ptr<SubqueryExpr> subquery);
  
  // 新增：子查询相关方法
  RC handle_subquery_comparison(const Tuple &tuple, bool &result) const;
  
private:
  // 现有成员...
  unique_ptr<SubqueryExpr> subquery_;   ///< 子查询表达式
  bool has_subquery_ = false;           ///< 是否包含子查询
};
```

**src/observer/sql/expr/expression.cpp**
```cpp
// SubqueryExpr 实现
SubqueryExpr::SubqueryExpr(SelectStmt *subquery_stmt) 
  : subquery_stmt_(subquery_stmt) {}

RC SubqueryExpr::get_values(const Tuple &tuple, std::vector<Value> &values) const {
  // 执行子查询并返回结果集
  if (!results_cached_) {
    RC rc = execute_subquery(cached_results_);
    if (rc != RC::SUCCESS) {
      return rc;
    }
    results_cached_ = true;
  }
  
  values = cached_results_;
  return RC::SUCCESS;
}

// ComparisonExpr 扩展实现
RC ComparisonExpr::handle_subquery_comparison(const Tuple &tuple, bool &result) const {
  if (!has_subquery_) {
    return RC::INVALID_ARGUMENT;
  }
  
  std::vector<Value> subquery_results;
  RC rc = subquery_->get_values(tuple, subquery_results);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  Value left_value;
  rc = left_->get_value(tuple, left_value);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  switch (comp_) {
    case IN_OP:
    case NOT_IN_OP:
      return handle_in_operation(left_value, subquery_results, result);
    case EXISTS_OP:
    case NOT_EXISTS_OP:
      return handle_exists_operation(subquery_results, result);
    default:
      return compare_with_subquery(left_value, subquery_results, result);
  }
}
```

#### 8.1.3 语义解析文件

**src/observer/sql/parser/expression_binder.cpp**
```cpp
// 在 bind_expression 方法中添加 SUBQUERY 类型处理
RC ExpressionBinder::bind_expression(unique_ptr<Expression> &expr, 
                                    vector<unique_ptr<Expression>> &bound_expressions) {
  switch (expr->type()) {
    // 现有处理...
    
    case ExprType::SUBQUERY: {
      return bind_subquery_expression(expr, bound_expressions);
    }
    
    // 其他情况...
  }
}

RC ExpressionBinder::bind_subquery_expression(unique_ptr<Expression> &expr, 
                                             vector<unique_ptr<Expression>> &bound_expressions) {
  auto subquery_expr = static_cast<SubqueryExpr *>(expr.get());
  
  // 绑定子查询中的表达式
  SelectStmt *subquery_stmt = subquery_expr->subquery_stmt();
  RC rc = bind_select_stmt(subquery_stmt);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  bound_expressions.emplace_back(std::move(expr));
  return RC::SUCCESS;
}
```

#### 8.1.4 算子实现文件

**src/observer/sql/operator/subquery_logical_operator.h**
```cpp
class SubqueryLogicalOperator : public LogicalOperator {
public:
  SubqueryLogicalOperator(SelectStmt *subquery_stmt);
  virtual ~SubqueryLogicalOperator() = default;

  LogicalOperatorType type() const override { 
    return LogicalOperatorType::SUBQUERY; 
  }

  RC generate_children_logical_operators(
    std::vector<std::unique_ptr<LogicalOperator>> &child_opers) override;

private:
  SelectStmt *subquery_stmt_;
};
```

**src/observer/sql/operator/subquery_physical_operator.h**
```cpp
class SubqueryPhysicalOperator : public PhysicalOperator {
public:
  SubqueryPhysicalOperator(std::unique_ptr<PhysicalOperator> child);
  virtual ~SubqueryPhysicalOperator() = default;

  PhysicalOperatorType type() const override { 
    return PhysicalOperatorType::SUBQUERY; 
  }

  RC open(Trx *trx) override;
  RC next() override;
  RC close() override;

  // 执行子查询并收集所有结果
  RC collect_subquery_results(std::vector<Value> &results);

private:
  std::vector<Value> results_;
  bool executed_ = false;
  size_t current_index_ = 0;
};
```

### 8.2 关键实现细节

#### 8.2.1 NULL 值处理策略

```cpp
RC ComparisonExpr::handle_in_operation(const Value &left_value, 
                                     const std::vector<Value> &subquery_results, 
                                     bool &result) const {
  result = false;
  bool found_null = false;
  
  // 处理左侧为 NULL 的情况
  if (left_value.is_null()) {
    result = false;  // NULL IN (...) 总是返回 NULL，在布尔上下文中为 false
    return RC::SUCCESS;
  }
  
  // 遍历子查询结果
  for (const Value &subquery_value : subquery_results) {
    if (subquery_value.is_null()) {
      found_null = true;
      continue;
    }
    
    // 执行类型转换（如果需要）
    Value converted_value;
    RC rc = try_convert_value(subquery_value, left_value.attr_type(), converted_value);
    if (rc != RC::SUCCESS) {
      continue;  // 类型转换失败，跳过该值
    }
    
    // 比较值
    int cmp_result = left_value.compare(converted_value);
    if (cmp_result == 0) {
      result = (comp_ == IN_OP);
      return RC::SUCCESS;
    }
  }
  
  // 没有找到匹配项
  if (found_null && comp_ == NOT_IN_OP) {
    // NOT IN 遇到 NULL 时返回 NULL（false）
    result = false;
  } else {
    result = (comp_ == NOT_IN_OP);
  }
  
  return RC::SUCCESS;
}
```

#### 8.2.2 类型转换实现

```cpp
RC try_convert_value(const Value &source, AttrType target_type, Value &result) {
  if (source.attr_type() == target_type) {
    result = source;
    return RC::SUCCESS;
  }
  
  // 利用现有的类型系统进行转换
  const DataType *source_type = DataType::type_instance(source.attr_type());
  const DataType *target_type_instance = DataType::type_instance(target_type);
  
  if (source_type == nullptr || target_type_instance == nullptr) {
    return RC::INVALID_ARGUMENT;
  }
  
  // 检查转换成本
  int cost = source_type->cast_cost(target_type);
  if (cost == INT32_MAX) {
    return RC::INVALID_ARGUMENT;  // 不支持的转换
  }
  
  // 执行转换
  return source_type->cast_to(source, target_type, result);
}
```

#### 8.2.3 子查询执行优化

```cpp
class SubqueryExecutor {
public:
  static RC execute_subquery(SelectStmt *subquery_stmt, 
                            std::vector<Value> &results) {
    // 创建执行计划
    std::unique_ptr<LogicalOperator> logical_plan;
    RC rc = LogicalPlanGenerator::create(subquery_stmt, logical_plan);
    if (rc != RC::SUCCESS) {
      return rc;
    }
    
    std::unique_ptr<PhysicalOperator> physical_plan;
    rc = PhysicalPlanGenerator::create(*logical_plan, physical_plan);
    if (rc != RC::SUCCESS) {
      return rc;
    }
    
    // 执行并收集结果
    rc = physical_plan->open(nullptr);
    if (rc != RC::SUCCESS) {
      return rc;
    }
    
    while ((rc = physical_plan->next()) == RC::SUCCESS) {
      Tuple *tuple = physical_plan->current_tuple();
      if (tuple == nullptr) {
        break;
      }
      
      // 提取结果值（假设只有一列）
      Value value;
      rc = tuple->cell_at(0, value);
      if (rc != RC::SUCCESS) {
        break;
      }
      
      results.push_back(value);
    }
    
    physical_plan->close();
    return (rc == RC::RECORD_EOF) ? RC::SUCCESS : rc;
  }
};
```

### 8.3 测试用例设计

#### 8.3.1 基础功能测试

```sql
-- 测试 IN 操作
CREATE TABLE users (id INT, name CHAR(20));
CREATE TABLE orders (id INT, user_id INT);

INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1), (2, 1), (3, 2);

-- 基本 IN 测试
SELECT * FROM users WHERE id IN (SELECT user_id FROM orders);
-- 期望结果：Alice, Bob

-- NOT IN 测试
SELECT * FROM users WHERE id NOT IN (SELECT user_id FROM orders);
-- 期望结果：Charlie
```

#### 8.3.2 NULL 值处理测试

```sql
-- 测试 NULL 值处理
INSERT INTO orders VALUES (4, NULL);

-- IN 操作遇到 NULL
SELECT * FROM users WHERE id IN (SELECT user_id FROM orders);
-- 期望结果：Alice, Bob（NULL 被忽略）

-- NOT IN 操作遇到 NULL
SELECT * FROM users WHERE id NOT IN (SELECT user_id FROM orders);
-- 期望结果：空集（因为子查询中有 NULL）
```

#### 8.3.3 类型转换测试

```sql
-- 测试类型转换
CREATE TABLE mixed_types (int_col INT, char_col CHAR(10));
INSERT INTO mixed_types VALUES (1, '1'), (2, '2'), (3, 'abc');

-- 整数与字符串比较
SELECT * FROM users WHERE id IN (SELECT char_col FROM mixed_types);
-- 期望结果：Alice, Bob（'abc' 转换失败被忽略）
```

#### 8.3.4 聚合函数测试

```sql
-- 测试聚合函数
CREATE TABLE salaries (emp_id INT, salary FLOAT);
INSERT INTO salaries VALUES (1, 5000.0), (2, 6000.0), (3, 5500.0);

-- 子查询包含聚合函数
SELECT * FROM users WHERE id IN (SELECT emp_id FROM salaries WHERE salary = (SELECT MAX(salary) FROM salaries));
-- 期望结果：Bob（emp_id=2，最高薪资）
```

### 8.4 性能考虑

#### 8.4.1 子查询结果缓存

```cpp
class SubqueryCache {
public:
  static SubqueryCache& instance() {
    static SubqueryCache cache;
    return cache;
  }
  
  bool get_cached_results(const std::string &query_hash, 
                         std::vector<Value> &results) {
    auto it = cache_.find(query_hash);
    if (it != cache_.end()) {
      results = it->second;
      return true;
    }
    return false;
  }
  
  void cache_results(const std::string &query_hash, 
                    const std::vector<Value> &results) {
    if (cache_.size() >= MAX_CACHE_SIZE) {
      cache_.clear();  // 简单的清理策略
    }
    cache_[query_hash] = results;
  }

private:
  static const size_t MAX_CACHE_SIZE = 100;
  std::unordered_map<std::string, std::vector<Value>> cache_;
};
```

#### 8.4.2 内存管理

```cpp
class SubqueryResultManager {
public:
  // 限制子查询结果集大小
  static const size_t MAX_SUBQUERY_RESULTS = 10000;
  
  static RC validate_result_size(size_t result_count) {
    if (result_count > MAX_SUBQUERY_RESULTS) {
      LOG_WARN("Subquery result set too large: %zu", result_count);
      return RC::RESOURCE_BUSY;
    }
    return RC::SUCCESS;
  }
};
```

## 9. 总结

本设计文档详细描述了在 MiniOB 中实现简单子查询功能的完整方案。该方案基于现有的架构，通过扩展语法分析器、表达式系统和执行引擎来实现子查询支持。设计考虑了 NULL 值处理、类型转换、错误处理、性能优化等重要方面，并提供了清晰的实现步骤、详细的代码示例和全面的测试计划。

### 9.1 主要特性

- **完整的子查询支持**：IN/NOT IN、EXISTS/NOT EXISTS、比较运算符
- **健壮的 NULL 值处理**：符合 SQL 标准的 NULL 值语义
- **灵活的类型转换**：利用现有类型系统进行自动转换
- **高效的执行策略**：结果缓存和内存管理优化
- **全面的测试覆盖**：单元测试、集成测试和边界情况测试

### 9.2 技术亮点

- **渐进式实现**：分阶段实现，降低开发风险
- **架构兼容性**：充分利用现有架构，最小化代码修改
- **标准符合性**：遵循 SQL 标准的子查询语义
- **可扩展性**：为后续功能（关联子查询）预留扩展空间

该功能的实现将显著增强 MiniOB 的 SQL 能力，为用户提供更丰富的查询选项，同时为后续的高级功能（如关联子查询、优化器增强）奠定坚实基础。
