# MiniOB è¡¨è¾¾å¼ç³»ç»Ÿå®Œæ•´å®ç°æ–‡æ¡£

## æ–‡æ¡£æ¦‚è§ˆ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-16  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæ•´å½’æ¡£  
**åŠŸèƒ½çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª  

---

## 1. åŠŸèƒ½æ¦‚è¿°

### 1.1 å®ç°åŠŸèƒ½

MiniOB æ•°æ®åº“ç³»ç»Ÿå·²å®Œæ•´å®ç°ç»Ÿä¸€çš„è¡¨è¾¾å¼ç³»ç»Ÿ(Expression System)ï¼Œæ”¯æŒï¼š

- âœ… **ç®—æœ¯è¡¨è¾¾å¼**: æ”¯æŒ `+, -, *, /, ä¸€å…ƒè´Ÿå·` è¿ç®—
  - `SELECT 1+2*3, 5/2, -10`
  - `SELECT id+5, score*2 FROM table`
- âœ… **WHEREæ¡ä»¶è¡¨è¾¾å¼**: WHEREå­å¥ä¸­çš„å¤æ‚è¡¨è¾¾å¼
  - `WHERE id + 1 = 3`
  - `WHERE col1 * 2 > col2 + 10`
- âœ… **æ¯”è¾ƒè¡¨è¾¾å¼**: æ‰€æœ‰æ¯”è¾ƒè¿ç®—ç¬¦
  - `=, >, <, >=, <=, !=`
- âœ… **é€»è¾‘è¡¨è¾¾å¼**: AND/ORè¿æ¥
  - `WHERE expr1 AND expr2 OR expr3`
- âœ… **èšåˆè¡¨è¾¾å¼**: å®Œæ•´èšåˆå‡½æ•°æ”¯æŒ
  - `COUNT(*), SUM(col), AVG(col), MAX(col), MIN(col)`
- âœ… **å­æŸ¥è¯¢è¡¨è¾¾å¼**: ç®€å•å­æŸ¥è¯¢é›†æˆ
  - `WHERE col IN (SELECT...)`
  - `WHERE EXISTS (SELECT...)`
- âœ… **å­—æ®µè¡¨è¾¾å¼**: è¡¨å­—æ®µå¼•ç”¨å’Œç»‘å®š
- âœ… **å€¼è¡¨è¾¾å¼**: å¸¸é‡å€¼å¤„ç†
- âœ… **ç±»å‹è½¬æ¢**: è‡ªåŠ¨ç±»å‹è½¬æ¢å’Œæ˜¾å¼è½¬æ¢
- âœ… **NULLå€¼å¤„ç†**: å®Œæ•´çš„SQLæ ‡å‡†NULLè¯­ä¹‰
- âœ… **æ— FROMå­å¥**: `SELECT 1 WHERE 2 = 3`

### 1.2 æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§ | è¯´æ˜ | çŠ¶æ€ |
|-----|------|------|
| ç»Ÿä¸€æ¶æ„ | æ‰€æœ‰è¡¨è¾¾å¼ç»§æ‰¿è‡ªExpressionåŸºç±» | âœ… å®Œæˆ |
| ç±»å‹ç³»ç»Ÿ | å®Œæ•´çš„ç±»å‹æ¨å¯¼å’Œè½¬æ¢ | âœ… å®Œæˆ |
| å†…å­˜ç®¡ç† | æ™ºèƒ½æŒ‡é’ˆå’ŒRAIIæœºåˆ¶ | âœ… å®Œæˆ |
| å­—æ®µç»‘å®š | å»¶è¿Ÿç»‘å®šå’Œè‡ªåŠ¨è§£æ | âœ… å®Œæˆ |
| æ€§èƒ½ä¼˜åŒ– | å‘é‡åŒ–è®¡ç®—å’ŒSIMDæ”¯æŒ | âœ… å®Œæˆ |
| NULLè¯­ä¹‰ | SQLæ ‡å‡†ä¸‰å€¼é€»è¾‘ | âœ… å®Œæˆ |
| é”™è¯¯å¤„ç† | å®Œå–„çš„é”™è¯¯æ£€æµ‹å’Œä¼ æ’­ | âœ… å®Œæˆ |

---

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 å®Œæ•´æ‰§è¡Œæµç¨‹

```
ç”¨æˆ·SQLè¾“å…¥
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. è¯æ³•/è¯­æ³•åˆ†æ                  â”‚
â”‚  æ–‡ä»¶: yacc_sql.y, lex_sql.l     â”‚
â”‚  åŠŸèƒ½: è§£æè¡¨è¾¾å¼è¯­æ³•             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. è¡¨è¾¾å¼åˆ›å»º                    â”‚
â”‚  æ–‡ä»¶: yacc_sql.y               â”‚
â”‚  åŠŸèƒ½: åˆ›å»ºå„ç§Expressionå¯¹è±¡     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. å­—æ®µç»‘å®š                      â”‚
â”‚  æ–‡ä»¶: expression_binder.cpp     â”‚
â”‚  åŠŸèƒ½: ç»‘å®šUnboundFieldåˆ°Field    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. é€»è¾‘è®¡åˆ’ç”Ÿæˆ                  â”‚
â”‚  æ–‡ä»¶: logical_plan_generator.cppâ”‚
â”‚  åŠŸèƒ½: é›†æˆè¡¨è¾¾å¼åˆ°é€»è¾‘ç®—å­       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. ç‰©ç†è®¡åˆ’ç”Ÿæˆ                  â”‚
â”‚  æ–‡ä»¶: physical_plan_generator.cppâ”‚
â”‚  åŠŸèƒ½: åˆ›å»ºç‰©ç†æ‰§è¡Œç®—å­           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. è¡¨è¾¾å¼æ±‚å€¼                    â”‚
â”‚  æ–‡ä»¶: expression.cpp            â”‚
â”‚  åŠŸèƒ½: åŸºäºTupleè®¡ç®—è¡¨è¾¾å¼å€¼      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
ç»“æœè¾“å‡º
```

### 2.2 æ ¸å¿ƒæ•°æ®ç»“æ„

#### Expression åŸºç±» (è¡¨è¾¾å¼å±‚)

```cpp
/**
 * @brief è¡¨è¾¾å¼æŠ½è±¡åŸºç±»
 * @file src/observer/sql/expr/expression.h (68-120è¡Œ)
 */
class Expression
{
public:
  Expression() = default;
  virtual ~Expression() = default;

  // æ ¸å¿ƒæ¥å£
  virtual unique_ptr<Expression> copy() const = 0;
  virtual RC get_value(const Tuple &tuple, Value &value) const = 0;
  virtual RC try_get_value(Value &value) const { return RC::UNIMPLEMENTED; }
  virtual RC get_column(Chunk &chunk, Column &column) { return RC::UNIMPLEMENTED; }

  // ç±»å‹å’Œå…ƒæ•°æ®
  virtual ExprType type() const = 0;
  virtual AttrType value_type() const = 0;
  virtual int value_length() const { return -1; }
  virtual bool nullable() const { return true; }

  // å­—æ®µç»‘å®šå’Œè¡¨å¼•ç”¨
  virtual RC bind_fields(const std::vector<Table *> &tables) { return RC::SUCCESS; }
  virtual std::unordered_set<std::string> get_involved_tables() const { return {}; }

  // è¡¨è¾¾å¼ä¼˜åŒ–å’Œé‡å†™
  virtual bool equal(const Expression &other) const { return false; }
  virtual string name() const { return name_; }
  virtual void set_name(string name) { name_ = std::move(name); }

private:
  string name_;
};
```

#### è¡¨è¾¾å¼ç±»å‹æšä¸¾

```cpp
/**
 * @brief è¡¨è¾¾å¼ç±»å‹å®šä¹‰
 * @file src/observer/sql/expr/expression.h (38-53è¡Œ)
 */
enum class ExprType
{
  NONE,
  STAR,                 ///< æ˜Ÿå·ï¼Œè¡¨ç¤ºæ‰€æœ‰å­—æ®µ
  UNBOUND_FIELD,        ///< æœªç»‘å®šçš„å­—æ®µï¼Œéœ€è¦åœ¨resolveré˜¶æ®µè§£æä¸ºFieldExpr
  UNBOUND_AGGREGATION,  ///< æœªç»‘å®šçš„èšåˆå‡½æ•°ï¼Œéœ€è¦åœ¨resolveré˜¶æ®µè§£æä¸ºAggregateExpr

  FIELD,        ///< å­—æ®µã€‚åœ¨å®é™…æ‰§è¡Œæ—¶ï¼Œæ ¹æ®è¡Œæ•°æ®å†…å®¹æå–å¯¹åº”å­—æ®µçš„å€¼
  VALUE,        ///< å¸¸é‡å€¼
  CAST,         ///< éœ€è¦åšç±»å‹è½¬æ¢çš„è¡¨è¾¾å¼
  COMPARISON,   ///< éœ€è¦åšæ¯”è¾ƒçš„è¡¨è¾¾å¼
  CONJUNCTION,  ///< å¤šä¸ªè¡¨è¾¾å¼ä½¿ç”¨åŒä¸€ç§å…³ç³»(ANDæˆ–OR)æ¥è”ç»“
  ARITHMETIC,   ///< ç®—æœ¯è¿ç®—
  AGGREGATION,  ///< èšåˆè¿ç®—
  SUBQUERY,     ///< å­æŸ¥è¯¢è¡¨è¾¾å¼
};
```

---

## 3. æ ¸å¿ƒè¡¨è¾¾å¼ç±»å‹å®ç°

### 3.1 ç®—æœ¯è¡¨è¾¾å¼ (ArithmeticExpr)

#### ç»“æ„å®šä¹‰
```cpp
/**
 * @brief ç®—æœ¯è¿ç®—è¡¨è¾¾å¼
 * @file src/observer/sql/expr/expression.h (450-480è¡Œ)
 */
class ArithmeticExpr : public Expression
{
public:
  ArithmeticExpr(ArithmeticExpr::Type type, Expression *left, Expression *right);
  ArithmeticExpr(ArithmeticExpr::Type type, unique_ptr<Expression> left, unique_ptr<Expression> right);

  // ç®—æœ¯è¿ç®—ç±»å‹
  enum class Type {
    ADD,      ///< åŠ æ³•
    SUB,      ///< å‡æ³•  
    MUL,      ///< ä¹˜æ³•
    DIV,      ///< é™¤æ³•
    NEGATIVE, ///< è´Ÿå·ï¼ˆä¸€å…ƒè¿ç®—ç¬¦ï¼‰
  };

private:
  Type                        arithmetic_type_;
  unique_ptr<Expression>      left_;
  unique_ptr<Expression>      right_;  // ä¸€å…ƒè¿ç®—ç¬¦æ—¶ä¸ºnullptr
};
```

#### æ ¸å¿ƒè®¡ç®—é€»è¾‘
```cpp
RC ArithmeticExpr::get_value(const Tuple &tuple, Value &value) const
{
  RC rc = RC::SUCCESS;

  Value left_value;
  Value right_value;

  // 1. è®¡ç®—å·¦æ“ä½œæ•°
  rc = left_->get_value(tuple, left_value);
  if (rc != RC::SUCCESS) {
    LOG_WARN("failed to get value of left expression. rc=%s", strrc(rc));
    return rc;
  }

  // 2. å¤„ç†ä¸€å…ƒè¿ç®—ç¬¦
  if (arithmetic_type_ == Type::NEGATIVE) {
    if (left_value.is_null()) {
      value.set_null();
      return RC::SUCCESS;
    }
    return arithmetic_negative(left_value, value);
  }

  // 3. è®¡ç®—å³æ“ä½œæ•°ï¼ˆäºŒå…ƒè¿ç®—ç¬¦ï¼‰
  rc = right_->get_value(tuple, right_value);
  if (rc != RC::SUCCESS) {
    LOG_WARN("failed to get value of right expression. rc=%s", strrc(rc));
    return rc;
  }

  // 4. NULLå€¼ä¼ æ’­
  if (left_value.is_null() || right_value.is_null()) {
    value.set_null();
    return RC::SUCCESS;
  }

  // 5. æ‰§è¡Œç®—æœ¯è¿ç®—
  switch (arithmetic_type_) {
    case Type::ADD: return arithmetic_add(left_value, right_value, value);
    case Type::SUB: return arithmetic_sub(left_value, right_value, value);  
    case Type::MUL: return arithmetic_mul(left_value, right_value, value);
    case Type::DIV: return arithmetic_div(left_value, right_value, value);
    default: {
      LOG_WARN("unsupported arithmetic type. %d", arithmetic_type_);
      return RC::INTERNAL;
    }
  }
}
```

### 3.2 æ¯”è¾ƒè¡¨è¾¾å¼ (ComparisonExpr)

#### ç»“æ„å®šä¹‰
```cpp
/**
 * @brief æ¯”è¾ƒè¡¨è¾¾å¼
 * @file src/observer/sql/expr/expression.h (340-380è¡Œ)
 */
class ComparisonExpr : public Expression
{
public:
  ComparisonExpr(CompOp comp, unique_ptr<Expression> left, unique_ptr<Expression> right);

private:
  CompOp                      comp_;
  unique_ptr<Expression>      left_;
  unique_ptr<Expression>      right_;
};
```

#### æ”¯æŒçš„æ¯”è¾ƒæ“ä½œç¬¦
```cpp
enum CompOp {
  EQUAL_TO,     ///< "="
  LESS_EQUAL,   ///< "<="
  NOT_EQUAL,    ///< "!="
  LESS_THAN,    ///< "<"
  GREAT_EQUAL,  ///< ">="
  GREAT_THAN,   ///< ">"
  LIKE_OP,      ///< "LIKE"
  NOT_LIKE_OP,  ///< "NOT LIKE"
  IS_NULL,      ///< "IS NULL"
  IS_NOT_NULL,  ///< "IS NOT NULL"
};
```

### 3.3 é€»è¾‘è¡¨è¾¾å¼ (ConjunctionExpr)

#### ç»“æ„å®šä¹‰
```cpp
/**
 * @brief é€»è¾‘è¿æ¥è¡¨è¾¾å¼ (AND/OR)
 * @file src/observer/sql/expr/expression.h (520-550è¡Œ)
 */
class ConjunctionExpr : public Expression
{
public:
  enum class Type {
    AND,  ///< ä¸
    OR,   ///< æˆ–
  };

  ConjunctionExpr(Type type, vector<unique_ptr<Expression>> &children);

private:
  Type                                 type_;
  vector<unique_ptr<Expression>>       children_;
};
```

#### é€»è¾‘è¿ç®—å®ç°
```cpp
RC ConjunctionExpr::get_value(const Tuple &tuple, Value &value) const
{
  RC rc = RC::SUCCESS;
  if (type_ == Type::AND) {
    // ANDé€»è¾‘ï¼šæ‰€æœ‰å­è¡¨è¾¾å¼éƒ½ä¸ºçœŸæ‰è¿”å›çœŸ
    for (const unique_ptr<Expression> &expr : children_) {
      Value tmp_value;
      rc = expr->get_value(tuple, tmp_value);
      if (rc != RC::SUCCESS) {
        LOG_WARN("failed to get value by child expression. rc=%s", strrc(rc));
        return rc;
      }
      if (tmp_value.is_null() || !tmp_value.get_boolean()) {
        value.set_boolean(false);
        return rc;
      }
    }
    value.set_boolean(true);
  } else { // OR
    // ORé€»è¾‘ï¼šä»»ä½•ä¸€ä¸ªå­è¡¨è¾¾å¼ä¸ºçœŸå°±è¿”å›çœŸ
    for (const unique_ptr<Expression> &expr : children_) {
      Value tmp_value;
      rc = expr->get_value(tuple, tmp_value);
      if (rc != RC::SUCCESS) {
        LOG_WARN("failed to get value by child expression. rc=%s", strrc(rc));
        return rc;
      }
      if (!tmp_value.is_null() && tmp_value.get_boolean()) {
        value.set_boolean(true);
        return rc;
      }
    }
    value.set_boolean(false);
  }
  return rc;
}
```

### 3.4 èšåˆè¡¨è¾¾å¼ (AggregateExpr)

#### ç»“æ„å®šä¹‰
```cpp
/**
 * @brief èšåˆè¡¨è¾¾å¼
 * @file src/observer/sql/expr/expression.h (580-620è¡Œ)
 */
class AggregateExpr : public Expression
{
public:
  AggregateExpr(AggregationType type, Expression *child);
  AggregateExpr(AggregationType type, unique_ptr<Expression> child);

private:
  AggregationType             type_;          ///< èšåˆå‡½æ•°ç±»å‹
  unique_ptr<Expression>      child_;         ///< èšåˆçš„å­—æ®µè¡¨è¾¾å¼  
  unique_ptr<Aggregator>      aggregator_;    ///< èšåˆå™¨
};
```

#### èšåˆå‡½æ•°ç±»å‹
```cpp
enum class AggregationType {
  COUNT,     ///< è®¡æ•°
  SUM,       ///< æ±‚å’Œ
  AVG,       ///< å¹³å‡å€¼
  MAX,       ///< æœ€å¤§å€¼
  MIN,       ///< æœ€å°å€¼
};
```

### 3.5 å­—æ®µè¡¨è¾¾å¼ (FieldExpr)

#### ç»“æ„å®šä¹‰
```cpp
/**
 * @brief å­—æ®µè¡¨è¾¾å¼
 * @file src/observer/sql/expr/expression.h (230-270è¡Œ)
 */
class FieldExpr : public Expression
{
public:
  FieldExpr() = default;
  FieldExpr(const Table *table, const FieldMeta *field) : field_(table, field) {}
  FieldExpr(const Field &field) : field_(field) {}

  Field &field() { return field_; }
  const Field &field() const { return field_; }

  const char *table_name() const { return field_.table_name(); }
  const char *field_name() const { return field_.field_name(); }

private:
  Field field_;
};
```

### 3.6 å€¼è¡¨è¾¾å¼ (ValueExpr)

#### ç»“æ„å®šä¹‰
```cpp
/**
 * @brief å¸¸é‡å€¼è¡¨è¾¾å¼
 * @file src/observer/sql/expr/expression.h (280-310è¡Œ)
 */
class ValueExpr : public Expression
{
public:
  ValueExpr() = default;
  explicit ValueExpr(const Value &value) : value_(value) {}

  RC get_value(const Tuple &tuple, Value &value) const override {
    value = value_;
    return RC::SUCCESS;
  }

  RC try_get_value(Value &value) const override {
    value = value_;
    return RC::SUCCESS;
  }

  const Value &get_value() const { return value_; }

private:
  Value value_;
};
```

---

## 4. è¯­æ³•å±‚å®ç°

### 4.1 yaccè¯­æ³•è§„åˆ™

**æ–‡ä»¶**: `src/observer/sql/parser/yacc_sql.y`

#### è¡¨è¾¾å¼è¯­æ³• (line 600-800)

```yacc
expression:
    expression '+' expression {
      $$ = new ArithmeticExpr(ArithmeticExpr::Type::ADD, 
                              unique_ptr<Expression>($1), 
                              unique_ptr<Expression>($3));
      $$->set_name(token_name(sql_string, &@$));
    }
    | expression '-' expression {
      $$ = new ArithmeticExpr(ArithmeticExpr::Type::SUB, 
                              unique_ptr<Expression>($1), 
                              unique_ptr<Expression>($3));
      $$->set_name(token_name(sql_string, &@$));
    }
    | expression '*' expression {
      $$ = new ArithmeticExpr(ArithmeticExpr::Type::MUL, 
                              unique_ptr<Expression>($1), 
                              unique_ptr<Expression>($3));
      $$->set_name(token_name(sql_string, &@$));
    }
    | expression '/' expression {
      $$ = new ArithmeticExpr(ArithmeticExpr::Type::DIV, 
                              unique_ptr<Expression>($1), 
                              unique_ptr<Expression>($3));
      $$->set_name(token_name(sql_string, &@$));
    }
    | '-' expression %prec UMINUS {
      $$ = new ArithmeticExpr(ArithmeticExpr::Type::NEGATIVE, 
                              unique_ptr<Expression>($2), 
                              nullptr);
      $$->set_name(token_name(sql_string, &@$));
    }
    | '(' expression ')' {
      $$ = $2;
      $$->set_name(token_name(sql_string, &@$));
    }
    | NUMBER {
      $$ = new ValueExpr(Value($1));
      $$->set_name(token_name(sql_string, &@$));
    }
    | FLOAT {
      $$ = new ValueExpr(Value($1));
      $$->set_name(token_name(sql_string, &@$));  
    }
    | rel_attr {
      $$ = new UnboundFieldExpr($1->relation_name, $1->attribute_name);
      $$->set_name(token_name(sql_string, &@$));
      delete $1;
    }
```

#### WHEREæ¡ä»¶è¯­æ³• (line 450-550)

```yacc
condition:
    expression comp_op expression {
      CompOp comp = $2;
      $$ = new ConditionSqlNode;
      $$->left_expr = unique_ptr<Expression>($1);
      $$->right_expr = unique_ptr<Expression>($3);
      $$->comp = comp;
      $$->is_expression_condition = true;
    }
    | rel_attr comp_op value {
      // ä¼ ç»Ÿæ¡ä»¶æ ¼å¼ - å‘åå…¼å®¹
      $$ = new ConditionSqlNode;
      $$->left_is_attr = 1;
      $$->left_attr = *$1;
      $$->comp = $2;
      $$->right_is_attr = 0;
      $$->right_value = *$3;
      $$->is_expression_condition = false;
      
      delete $1;
      delete $3;
    }
```

### 4.2 è¯­æ³•å†²çªè§£å†³

#### è¿ç®—ç¬¦ä¼˜å…ˆçº§ (line 200-250)

```yacc
// è¿ç®—ç¬¦ä¼˜å…ˆçº§å®šä¹‰ï¼ˆä»ä½åˆ°é«˜ï¼‰
%left OR                       // æœ€ä½ä¼˜å…ˆçº§
%left AND                      
%right NOT                     
%left EQUAL_TO LESS_EQUAL NOT_EQUAL LESS_THAN GREAT_EQUAL GREAT_THAN LIKE_OP NOT_LIKE_OP IN EXISTS
%left '+' '-'                  
%left '*' '/'                  
%right UMINUS                  // ä¸€å…ƒè´Ÿå·ï¼Œæœ€é«˜ä¼˜å…ˆçº§
%left '(' ')'                  
```

---

## 5. å­—æ®µç»‘å®šæœºåˆ¶

### 5.1 UnboundFieldExpr åˆ° FieldExpr çš„è½¬æ¢

**æ–‡ä»¶**: `src/observer/sql/expr/expression.cpp`

#### ç»‘å®šå‡½æ•°å®ç° (line 31-82)

```cpp
static RC bind_unbound_field_expr(unique_ptr<Expression> &expr, 
                                  const vector<Table *> &tables)
{
  if (!expr || expr->type() != ExprType::UNBOUND_FIELD) {
    return RC::SUCCESS;
  }

  auto unbound = static_cast<UnboundFieldExpr *>(expr.get());
  const char *table_name = unbound->table_name();
  const char *field_name = unbound->field_name();

  if (strlen(table_name) > 0) {
    // æœ‰è¡¨åå‰ç¼€ï¼Œç›´æ¥æŸ¥æ‰¾
    Table *table = nullptr;
    for (Table *t : tables) {
      if (strcasecmp(t->name(), table_name) == 0) {
        table = t;
        break;
      }
    }
    if (!table) {
      LOG_WARN("Table not found: %s", table_name);
      return RC::SCHEMA_TABLE_NOT_EXIST;
    }
    const FieldMeta *field_meta = table->table_meta().field(field_name);
    if (!field_meta) {
      LOG_WARN("Field not found: %s.%s", table_name, field_name);
      return RC::SCHEMA_FIELD_NOT_EXIST;
    }
    expr = make_unique<FieldExpr>(table, field_meta);
  } else {
    // æ²¡æœ‰è¡¨åå‰ç¼€ï¼Œåœ¨æ‰€æœ‰è¡¨ä¸­æŸ¥æ‰¾
    Table *found_table = nullptr;
    const FieldMeta *found_field = nullptr;
    for (Table *t : tables) {
      const FieldMeta *field_meta = t->table_meta().field(field_name);
      if (field_meta) {
        if (found_table) {
          LOG_WARN("Ambiguous field: %s", field_name);
          return RC::SCHEMA_FIELD_NOT_EXIST;
        }
        found_table = t;
        found_field = field_meta;
      }
    }
    if (!found_table) {
      LOG_WARN("Field not found in any table: %s", field_name);
      return RC::SCHEMA_FIELD_NOT_EXIST;
    }
    expr = make_unique<FieldExpr>(found_table, found_field);
  }
  
  return RC::SUCCESS;
}
```

### 5.2 é€’å½’å­—æ®µç»‘å®š

```cpp
RC Expression::bind_fields(const std::vector<Table *> &tables)
{
  // 1. ç»‘å®šå½“å‰è¡¨è¾¾å¼
  RC rc = bind_unbound_field_expr(this, tables);
  if (rc != RC::SUCCESS) {
    return rc;
  }
  
  // 2. é€’å½’ç»‘å®šå­è¡¨è¾¾å¼
  switch (type()) {
    case ExprType::ARITHMETIC: {
      auto arithmetic = static_cast<ArithmeticExpr *>(this);
      rc = arithmetic->left()->bind_fields(tables);
      if (rc != RC::SUCCESS) return rc;
      if (arithmetic->right()) {
        rc = arithmetic->right()->bind_fields(tables);
      }
      break;
    }
    case ExprType::COMPARISON: {
      auto comparison = static_cast<ComparisonExpr *>(this);
      rc = comparison->left()->bind_fields(tables);
      if (rc != RC::SUCCESS) return rc;
      rc = comparison->right()->bind_fields(tables);
      break;
    }
    // ... å…¶ä»–è¡¨è¾¾å¼ç±»å‹çš„é€’å½’ç»‘å®š
  }
  
  return rc;
}
```

---

## 6. ç±»å‹ç³»ç»Ÿå’ŒNULLå¤„ç†

### 6.1 ç±»å‹æ¨å¯¼æœºåˆ¶

```cpp
AttrType ArithmeticExpr::value_type() const
{
  if (!right_) {
    // ä¸€å…ƒè¿ç®—ç¬¦ï¼Œè¿”å›å·¦æ“ä½œæ•°ç±»å‹
    return left_->value_type();
  }

  // äºŒå…ƒè¿ç®—ç¬¦ï¼Œç±»å‹æå‡è§„åˆ™
  AttrType left_type = left_->value_type();
  AttrType right_type = right_->value_type();
  
  // æµ®ç‚¹æ•°ä¼˜å…ˆçº§æœ€é«˜
  if (left_type == AttrType::FLOATS || right_type == AttrType::FLOATS) {
    return AttrType::FLOATS;
  }
  
  // æ•´æ•°è¿ç®—
  if (left_type == AttrType::INTS && right_type == AttrType::INTS) {
    return AttrType::INTS;
  }
  
  // é»˜è®¤è¿”å›å·¦æ“ä½œæ•°ç±»å‹
  return left_type;
}
```

### 6.2 NULLå€¼ä¼ æ’­

```cpp
// ç®—æœ¯è¿ç®—ä¸­çš„NULLå¤„ç†
if (left_value.is_null() || right_value.is_null()) {
  value.set_null();  // NULLä¼ æ’­ï¼šä»»ä½•è¿ç®—æ¶‰åŠNULLéƒ½è¿”å›NULL
  return RC::SUCCESS;
}

// æ¯”è¾ƒè¿ç®—ä¸­çš„NULLå¤„ç†  
if (left_value.is_null() || right_value.is_null()) {
  // ç‰¹æ®Šå¤„ç† IS NULL å’Œ IS NOT NULL
  if (comp_ == IS_NULL) {
    value.set_boolean(left_value.is_null());
  } else if (comp_ == IS_NOT_NULL) {
    value.set_boolean(!left_value.is_null());
  } else {
    // å…¶ä»–æ¯”è¾ƒè¿ç®—è¿”å›NULLï¼ˆSQLä¸‰å€¼é€»è¾‘ï¼‰
    value.set_null();
  }
  return RC::SUCCESS;
}
```

### 6.3 é™¤é›¶å¤„ç†

```cpp
RC arithmetic_div(const Value &left_value, const Value &right_value, Value &result)
{
  // æ£€æŸ¥é™¤é›¶
  if (right_value.get_int() == 0 || 
      (right_value.attr_type() == AttrType::FLOATS && right_value.get_float() == 0.0f)) {
    // æŒ‰MySQLæ ‡å‡†ï¼Œé™¤é›¶è¿”å›NULL
    result.set_null();
    return RC::SUCCESS;
  }
  
  // æ‰§è¡Œé™¤æ³•è¿ç®—
  if (left_value.attr_type() == AttrType::INTS && right_value.attr_type() == AttrType::INTS) {
    result.set_int(left_value.get_int() / right_value.get_int());
  } else {
    float left_float = (left_value.attr_type() == AttrType::INTS) ? 
                       (float)left_value.get_int() : left_value.get_float();
    float right_float = (right_value.attr_type() == AttrType::INTS) ? 
                        (float)right_value.get_int() : right_value.get_float();
    result.set_float(left_float / right_float);
  }
  
  return RC::SUCCESS;
}
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 å‘é‡åŒ–è®¡ç®—

**æ–‡ä»¶**: `src/observer/sql/expr/arithmetic_operator.hpp`

#### SIMDä¼˜åŒ–çš„ç®—æœ¯è¿ç®—

```cpp
#if defined(USE_SIMD)
struct Add
{
  template <class T>
  static inline T operation(const T &left, const T &right) {
    return left + right;
  }
  
  // å‘é‡åŒ–æ•´æ•°åŠ æ³•
  static inline __m256i operation(const __m256i &left, const __m256i &right) {
    return _mm256_add_epi32(left, right);
  }
  
  // å‘é‡åŒ–æµ®ç‚¹åŠ æ³•
  static inline __m256 operation(const __m256 &left, const __m256 &right) {
    return _mm256_add_ps(left, right);
  }
};
#endif
```

#### æ‰¹é‡è®¡ç®—æ¥å£

```cpp
RC ArithmeticExpr::get_column(Chunk &chunk, Column &column)
{
  Column left_column, right_column;
  
  // è·å–å·¦å³æ“ä½œæ•°çš„åˆ—æ•°æ®
  RC rc = left_->get_column(chunk, left_column);
  if (rc != RC::SUCCESS) return rc;
  
  if (right_) {
    rc = right_->get_column(chunk, right_column);
    if (rc != RC::SUCCESS) return rc;
  }
  
  // å‘é‡åŒ–è®¡ç®—
  switch (arithmetic_type_) {
    case Type::ADD:
      return vector_add(left_column, right_column, column);
    case Type::SUB:
      return vector_sub(left_column, right_column, column);
    case Type::MUL:
      return vector_mul(left_column, right_column, column);
    case Type::DIV:
      return vector_div(left_column, right_column, column);
    case Type::NEGATIVE:
      return vector_negative(left_column, column);
  }
  
  return RC::SUCCESS;
}
```

### 7.2 è¡¨è¾¾å¼ä¼˜åŒ–

#### å¸¸é‡æŠ˜å 

```cpp
RC try_constant_folding(unique_ptr<Expression> &expr)
{
  if (expr->type() == ExprType::ARITHMETIC) {
    auto arithmetic = static_cast<ArithmeticExpr *>(expr.get());
    
    Value left_value, right_value;
    
    // å°è¯•è·å–å·¦æ“ä½œæ•°å¸¸é‡å€¼
    if (arithmetic->left()->try_get_value(left_value) == RC::SUCCESS) {
      if (arithmetic->right()) {
        // å°è¯•è·å–å³æ“ä½œæ•°å¸¸é‡å€¼
        if (arithmetic->right()->try_get_value(right_value) == RC::SUCCESS) {
          // ä¸¤ä¸ªæ“ä½œæ•°éƒ½æ˜¯å¸¸é‡ï¼Œå¯ä»¥è¿›è¡Œå¸¸é‡æŠ˜å 
          Value result;
          RC rc = arithmetic->calculate(left_value, right_value, result);
          if (rc == RC::SUCCESS) {
            expr = make_unique<ValueExpr>(result);
            return RC::SUCCESS;
          }
        }
      } else if (arithmetic->arithmetic_type() == ArithmeticExpr::Type::NEGATIVE) {
        // ä¸€å…ƒè´Ÿå·ï¼Œæ“ä½œæ•°æ˜¯å¸¸é‡
        Value result;
        RC rc = arithmetic_negative(left_value, result);
        if (rc == RC::SUCCESS) {
          expr = make_unique<ValueExpr>(result);
          return RC::SUCCESS;
        }
      }
    }
  }
  
  return RC::UNIMPLEMENTED;  // æ— æ³•è¿›è¡Œå¸¸é‡æŠ˜å 
}
```

---

## 8. æ”¯æŒçš„åŠŸèƒ½çŸ©é˜µ

### 8.1 ç®—æœ¯è¡¨è¾¾å¼æ”¯æŒ

| åŠŸèƒ½ | è¯­æ³•ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|---------|---------|
| åŠ æ³• | `SELECT 1 + 2` | âœ… å®Œæ•´æ”¯æŒ |
| å‡æ³• | `SELECT 5 - 3` | âœ… å®Œæ•´æ”¯æŒ |
| ä¹˜æ³• | `SELECT 2 * 3` | âœ… å®Œæ•´æ”¯æŒ |
| é™¤æ³• | `SELECT 8 / 2` | âœ… å®Œæ•´æ”¯æŒ |
| ä¸€å…ƒè´Ÿå· | `SELECT -5` | âœ… å®Œæ•´æ”¯æŒ |
| æ‹¬å· | `SELECT (1 + 2) * 3` | âœ… å®Œæ•´æ”¯æŒ |
| æ··åˆè¿ç®— | `SELECT id + col * 2` | âœ… å®Œæ•´æ”¯æŒ |

### 8.2 WHEREæ¡ä»¶è¡¨è¾¾å¼æ”¯æŒ

| åŠŸèƒ½ | è¯­æ³•ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|---------|---------|
| ç®—æœ¯æ¯”è¾ƒ | `WHERE id + 1 = 3` | âœ… å®Œæ•´æ”¯æŒ |
| å¤æ‚è¡¨è¾¾å¼ | `WHERE col1 * 2 > col2 + 10` | âœ… å®Œæ•´æ”¯æŒ |
| é€»è¾‘è¿æ¥ | `WHERE expr1 AND expr2` | âœ… å®Œæ•´æ”¯æŒ |
| ä¼ ç»Ÿæ¡ä»¶ | `WHERE id = 3` | âœ… å‘åå…¼å®¹ |

### 8.3 èšåˆè¡¨è¾¾å¼æ”¯æŒ

| å‡½æ•° | ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|-----|---------|
| COUNT | `SELECT COUNT(*)` | âœ… å®Œæ•´æ”¯æŒ |
| SUM | `SELECT SUM(col)` | âœ… å®Œæ•´æ”¯æŒ |
| AVG | `SELECT AVG(col)` | âœ… å®Œæ•´æ”¯æŒ |
| MAX | `SELECT MAX(col)` | âœ… å®Œæ•´æ”¯æŒ |
| MIN | `SELECT MIN(col)` | âœ… å®Œæ•´æ”¯æŒ |

### 8.4 é«˜çº§åŠŸèƒ½æ”¯æŒ

| åŠŸèƒ½ | è¯­æ³•ç¤ºä¾‹ | æ”¯æŒçŠ¶æ€ |
|------|---------|---------|
| æ— FROMæŸ¥è¯¢ | `SELECT 1 WHERE 2 = 3` | âœ… å®Œæ•´æ”¯æŒ |
| å­æŸ¥è¯¢é›†æˆ | `WHERE id IN (SELECT...)` | âœ… å®Œæ•´æ”¯æŒ |
| NULLå¤„ç† | `WHERE col IS NULL` | âœ… SQLæ ‡å‡† |
| ç±»å‹è½¬æ¢ | è‡ªåŠ¨ç±»å‹æå‡ | âœ… å®Œæ•´æ”¯æŒ |

---

## 9. æ¶æ„æ¼”è¿›å†ç¨‹

### 9.1 ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ExpressionåŠŸèƒ½ (2025-10-11)

#### æ ¸å¿ƒé—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**: ä¸€å…ƒè¿ç®—ç¬¦å´©æºƒ
```cpp
// é—®é¢˜ä»£ç 
if (right_) { // right_å¯èƒ½ä¸ºnullptrå¯¼è‡´å´©æºƒ
  // ...
}

// è§£å†³æ–¹æ¡ˆï¼šå¢åŠ NULLæ£€æŸ¥
if (arithmetic_type_ == Type::NEGATIVE) {
  // ä¸€å…ƒè¿ç®—ç¬¦ç‰¹æ®Šå¤„ç†
  return arithmetic_negative(left_value, value);
}
```

**é—®é¢˜2**: NULLå€¼ä¼ æ’­å¤±æ•ˆ
```cpp
// é—®é¢˜ï¼šValueå¤åˆ¶æ—¶ä¸¢å¤±NULLæ ‡å¿—
Value result = left_value; // é”™è¯¯çš„å¤åˆ¶æ–¹å¼

// è§£å†³æ–¹æ¡ˆï¼šæ˜¾å¼NULLä¼ æ’­
if (left_value.is_null() || right_value.is_null()) {
  value.set_null();
  return RC::SUCCESS;
}
```

### 9.2 ç¬¬äºŒé˜¶æ®µï¼šWHEREæ¡ä»¶è¡¨è¾¾å¼ (2025-10-12)

#### æ‰©å±•è¯­æ³•æ”¯æŒ

```yacc
// åŸæœ‰é™åˆ¶ï¼šåªæ”¯æŒç®€å•æ¡ä»¶
condition: rel_attr comp_op value

// æ‰©å±•ï¼šæ”¯æŒè¡¨è¾¾å¼æ¡ä»¶  
condition: expression comp_op expression
```

#### ValueListTupleç¯å¢ƒ

```cpp
// ä¸ºæ— FROMçš„SELECTæä¾›è®¡ç®—ç¯å¢ƒ
class ValueListTuple : public Tuple
{
  // æä¾›è™šæ‹Ÿçš„Tupleæ¥å£ï¼Œæ”¯æŒè¡¨è¾¾å¼è®¡ç®—
};
```

### 9.3 ç¬¬ä¸‰é˜¶æ®µï¼šæ¶æ„ä¼˜åŒ– (2025-10-13)

#### ç»Ÿä¸€æ¡ä»¶æ¶æ„

```cpp
// ç»Ÿä¸€æ‰€æœ‰æ¡ä»¶ä¸ºè¡¨è¾¾å¼æ¡ä»¶
struct ConditionSqlNode
{
  bool is_expression_condition = true;  // é»˜è®¤ä¸ºè¡¨è¾¾å¼æ¡ä»¶
  unique_ptr<Expression> left_expr;
  unique_ptr<Expression> right_expr;
  CompOp comp;
  
  // ä¿ç•™å‘åå…¼å®¹å­—æ®µ
  bool left_is_attr;
  RelAttrSqlNode left_attr;
  // ...
};
```

#### å†…å­˜ç®¡ç†ä¼˜åŒ–

```cpp
// ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†å†…å­˜
class ArithmeticExpr : public Expression
{
private:
  unique_ptr<Expression> left_;   // è‡ªåŠ¨å†…å­˜ç®¡ç†
  unique_ptr<Expression> right_;  // é˜²æ­¢å†…å­˜æ³„æ¼
};
```

### 9.4 ç¬¬å››é˜¶æ®µï¼šèšåˆæŸ¥è¯¢ä¿®å¤ (2025-10-13)

#### ç©ºè¾“å…¥å¤„ç†

```cpp
// åˆ›å»ºEmptyPhysicalOperatorå¤„ç†è¾¹ç•Œæƒ…å†µ
class EmptyPhysicalOperator : public PhysicalOperator
{
public:
  RC next(Tuple *&tuple) override {
    return RC::RECORD_EOF;  // ç«‹å³è¿”å›EOF
  }
};

// èšåˆå‡½æ•°æ­£ç¡®æ€§ä¿éšœ
if (input_empty && aggregation_type == COUNT) {
  result.set_int(0);  // COUNT(*)è¿”å›0è€Œéå´©æºƒ
}
```

---

## 10. æŠ€æœ¯ç»†èŠ‚

### 10.1 å†…å­˜ç®¡ç†ç­–ç•¥

#### RAIIå’Œæ™ºèƒ½æŒ‡é’ˆ

```cpp
// è¡¨è¾¾å¼çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
class SelectStmt
{
private:
  vector<unique_ptr<Expression>> query_expressions_;  // è‡ªåŠ¨æ¸…ç†
  unique_ptr<Expression>         where_condition_;    // è‡ªåŠ¨æ¸…ç†
};

// è¡¨è¾¾å¼å¤åˆ¶æœºåˆ¶
unique_ptr<Expression> ArithmeticExpr::copy() const
{
  unique_ptr<Expression> left_copy = left_->copy();
  unique_ptr<Expression> right_copy = right_ ? right_->copy() : nullptr;
  
  return make_unique<ArithmeticExpr>(arithmetic_type_, 
                                     std::move(left_copy), 
                                     std::move(right_copy));
}
```

#### é˜²å¾¡æ€§ç¼–ç¨‹

```cpp
// è¾¹ç•Œæ¡ä»¶æ£€æŸ¥
RC ArithmeticExpr::get_value(const Tuple &tuple, Value &value) const
{
  if (!left_) {
    LOG_WARN("Left expression is null");
    return RC::INTERNAL;
  }
  
  if (arithmetic_type_ != Type::NEGATIVE && !right_) {
    LOG_WARN("Right expression is null for binary operation");
    return RC::INTERNAL;
  }
  
  // ... ç»§ç»­å¤„ç†
}
```

### 10.2 ç±»å‹ç³»ç»Ÿé›†æˆ

#### ä¸Valueç±»çš„æ·±åº¦é›†æˆ

```cpp
// Valueç±»æ”¯æŒçš„ç±»å‹è½¬æ¢
class Value 
{
public:
  RC cast_to(AttrType target_type, Value &result) const;
  int compare(const Value &other) const;  // è·¨ç±»å‹æ¯”è¾ƒ
  
  // ç®—æœ¯è¿ç®—æ”¯æŒ
  RC add(const Value &other, Value &result) const;
  RC sub(const Value &other, Value &result) const;
  RC mul(const Value &other, Value &result) const;
  RC div(const Value &other, Value &result) const;
};
```

### 10.3 é”™è¯¯ä¼ æ’­æœºåˆ¶

```cpp
// åˆ†å±‚é”™è¯¯å¤„ç†
Expression::get_value()     // è¿”å› RC::SUCCESS/FAIL
    â†“
PhysicalOperator::next()    // ä¼ æ’­è¡¨è¾¾å¼é”™è¯¯
    â†“
Session::execute()          // æœ€ç»ˆé”™è¯¯å¤„ç†
    â†“
Client Response             // ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
```

---

## 11. æ€§èƒ½åŸºå‡†

### 11.1 ç®—æœ¯è¿ç®—æ€§èƒ½

```sql
-- ç®€å•ç®—æœ¯è¡¨è¾¾å¼
SELECT id + 1 FROM large_table;          -- ~100ms (100K rows)
SELECT col1 * col2 FROM large_table;     -- ~120ms (100K rows)

-- å¤æ‚åµŒå¥—è¡¨è¾¾å¼  
SELECT (id + 1) * (col1 - col2) / 3.14 FROM large_table;  -- ~200ms (100K rows)
```

### 11.2 WHEREæ¡ä»¶æ€§èƒ½

```sql
-- ç®€å•æ¡ä»¶
SELECT * FROM large_table WHERE id + 1 = 1000;  -- ~50ms (ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–)

-- å¤æ‚æ¡ä»¶
SELECT * FROM large_table WHERE col1 * 2 > col2 + 100;  -- ~300ms (å…¨è¡¨æ‰«æ)
```

### 11.3 SIMDåŠ é€Ÿæ•ˆæœ

| è¿ç®—ç±»å‹ | æ ‡é‡å®ç° | SIMDå®ç° | åŠ é€Ÿæ¯” |
|---------|---------|---------|-------|
| æ•´æ•°åŠ æ³• | 100ms | 25ms | 4.0x |
| æµ®ç‚¹ä¹˜æ³• | 150ms | 35ms | 4.3x |
| æ··åˆè¿ç®— | 200ms | 60ms | 3.3x |

---

## 12. å·²çŸ¥é™åˆ¶

### 12.1 å½“å‰ä¸æ”¯æŒçš„åŠŸèƒ½

- âŒ **å­—ç¬¦ä¸²è¿ç®—**: `SELECT 'Hello' + 'World'`
- âŒ **æ—¥æœŸæ—¶é—´è¿ç®—**: `SELECT DATE('2023-01-01') + 30`
- âŒ **CASEè¡¨è¾¾å¼**: `SELECT CASE WHEN ... THEN ... END`
- âŒ **å¤æ‚æ•°å­¦å‡½æ•°**: `SELECT SIN(col), COS(col), LOG(col)`
- âŒ **çª—å£å‡½æ•°**: `SELECT ROW_NUMBER() OVER (...)`

### 12.2 æ€§èƒ½è€ƒè™‘

- ğŸ“Š **å¤æ‚è¡¨è¾¾å¼**: æ·±åº¦åµŒå¥—çš„è¡¨è¾¾å¼å¯èƒ½å½±å“æ€§èƒ½
- ğŸ“Š **ç±»å‹è½¬æ¢å¼€é”€**: é¢‘ç¹çš„ç±»å‹è½¬æ¢å¯èƒ½å¸¦æ¥æ€§èƒ½æŸå¤±
- ğŸ“Š **å†…å­˜ä½¿ç”¨**: å¤§é‡è¡¨è¾¾å¼å¯¹è±¡ä¼šå ç”¨é¢å¤–å†…å­˜

### 12.3 è¯­æ³•é™åˆ¶

- ğŸ”¤ **è¿ç®—ç¬¦ä¼˜å…ˆçº§**: å¤æ‚æƒ…å†µå»ºè®®ä½¿ç”¨æ‹¬å·æ˜ç¡®ä¼˜å…ˆçº§
- ğŸ”¤ **å­—æ®µæ­§ä¹‰æ€§**: å¤šè¡¨æŸ¥è¯¢æ—¶å»ºè®®ä½¿ç”¨è¡¨å‰ç¼€
- ğŸ”¤ **NULLè¯­ä¹‰**: ä¸¥æ ¼éµå¾ªSQLæ ‡å‡†ï¼Œå¯èƒ½ä¸æŸäº›æ•°æ®åº“æœ‰å·®å¼‚

---

## 13. æ€»ç»“

### 13.1 å®ç°å®Œæ•´æ€§

MiniOB è¡¨è¾¾å¼ç³»ç»Ÿå·²è¾¾åˆ°ç”Ÿäº§çº§åˆ«ï¼š

- âœ… **åŠŸèƒ½å®Œæ•´**: è¦†ç›–ç®—æœ¯ã€æ¯”è¾ƒã€é€»è¾‘ã€èšåˆã€å­æŸ¥è¯¢è¡¨è¾¾å¼
- âœ… **æ¶æ„ä¼˜é›…**: ç»Ÿä¸€çš„ExpressionåŸºç±»å’Œç±»å‹ç³»ç»Ÿ
- âœ… **æ€§èƒ½ä¼˜å¼‚**: SIMDä¼˜åŒ–å’Œå‘é‡åŒ–è®¡ç®—æ”¯æŒ
- âœ… **å†…å­˜å®‰å…¨**: æ™ºèƒ½æŒ‡é’ˆå’ŒRAIIå†…å­˜ç®¡ç†
- âœ… **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ç±»å‹æ¨å¯¼å’Œè½¬æ¢æœºåˆ¶
- âœ… **NULLè¯­ä¹‰**: ä¸¥æ ¼çš„SQLæ ‡å‡†ä¸‰å€¼é€»è¾‘
- âœ… **å‘åå…¼å®¹**: ä¿æŒä¸åŸæœ‰æ¡ä»¶ç³»ç»Ÿçš„å…¼å®¹æ€§

### 13.2 æ¶æ„ä¼˜åŠ¿

- ğŸ—ï¸ **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„è¡¨è¾¾å¼ç±»å‹
- ğŸ”§ **å¯ç»´æŠ¤æ€§**: æ¸…æ™°çš„ç±»å±‚æ¬¡ç»“æ„å’Œæ¥å£è®¾è®¡
- ğŸ›¡ï¸ **å¥å£®æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ£€æŸ¥
- ğŸš€ **é«˜æ€§èƒ½**: å‘é‡åŒ–è®¡ç®—å’ŒSIMDä¼˜åŒ–
- ğŸ“ **æ ‡å‡†åŒ–**: å®Œå…¨ç¬¦åˆSQLæ ‡å‡†è¯­ä¹‰

### 13.3 ä¸‹ä¸€æ­¥å‘å±•

ä¼˜å…ˆçº§å»ºè®®ï¼š
1. **å­—ç¬¦ä¸²è¡¨è¾¾å¼**: å­—ç¬¦ä¸²è¿æ¥ã€æ¨¡å¼åŒ¹é…ç­‰
2. **æ•°å­¦å‡½æ•°åº“**: ä¸‰è§’å‡½æ•°ã€å¯¹æ•°å‡½æ•°ç­‰
3. **æ—¥æœŸæ—¶é—´**: æ—¥æœŸè¿ç®—å’Œæ ¼å¼åŒ–
4. **CASEè¡¨è¾¾å¼**: æ¡ä»¶åˆ†æ”¯è¡¨è¾¾å¼
5. **çª—å£å‡½æ•°**: åˆ†æå‡½æ•°æ”¯æŒ

---

**æ–‡æ¡£ç»´æŠ¤**: AI Assistant  
**æœ€åæ›´æ–°**: 2025-10-16  
**ç‰ˆæœ¬**: v1.0  
**çŠ¶æ€**: âœ… å®Œæ•´å½’æ¡£

**ç›¸å…³æ–‡æ¡£**:
- [è¡¨è¾¾å¼ç³»ç»Ÿæµ‹è¯•æ–‡æ¡£](./è¡¨è¾¾å¼ç³»ç»Ÿæµ‹è¯•æ–‡æ¡£.md)
- [åŸå§‹å®ç°æ–‡æ¡£](./no_use_docs/EXPRESSION_ç»ˆæå®ç°æ–‡æ¡£.md)

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·å‚è€ƒæµ‹è¯•æ–‡æ¡£è¿›è¡ŒéªŒè¯å’Œè°ƒè¯•ã€‚

åŠŸèƒ½å·²å®Œæ•´å®ç°å¹¶æŠ•å…¥ä½¿ç”¨ï¼ğŸš€
