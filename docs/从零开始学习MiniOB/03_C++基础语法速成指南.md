# C++基础语法速成指南 - 专为MiniOB学习定制

## 🎯 学习目标

这个指南专门针对学习MiniOB项目，涵盖项目中用到的所有重要C++语法，让你能够顺利阅读和理解代码。

## 📚 目录

1. [类和对象基础](#1-类和对象基础)
2. [指针和引用](#2-指针和引用)
3. [智能指针](#3-智能指针)
4. [继承和多态](#4-继承和多态)
5. [容器和迭代器](#5-容器和迭代器)
6. [模板基础](#6-模板基础)
7. [异常处理](#7-异常处理)
8. [现代C++特性](#8-现代c特性)

## 1. 类和对象基础

### 1.1 基本类定义
```cpp
// 在MiniOB中的例子：Table类
class Table {
private:                    // 私有成员，外部不能直接访问
    string name_;          // 成员变量（表名）
    int record_count_;     // 成员变量（记录数）
    
public:                    // 公有成员，外部可以访问
    Table();               // 默认构造函数
    Table(const string& name);  // 带参数的构造函数
    ~Table();              // 析构函数
    
    // 成员函数
    RC insert_record(const Record& record);
    RC delete_record(const RID& rid);
    
    // getter和setter
    const string& name() const { return name_; }  // 内联函数
    void set_name(const string& name) { name_ = name; }
};
```

### 1.2 构造函数和析构函数
```cpp
// 构造函数：创建对象时自动调用
Table::Table() : name_(""), record_count_(0) {  // 初始化列表
    cout << "创建了一个空表" << endl;
}

Table::Table(const string& name) : name_(name), record_count_(0) {
    cout << "创建了表：" << name << endl;
}

// 析构函数：对象销毁时自动调用
Table::~Table() {
    cout << "销毁表：" << name_ << endl;
    // 释放资源，关闭文件等
}

// 使用示例
Table students_table("students");  // 调用带参构造函数
// 函数结束时自动调用析构函数
```

### 1.3 const关键字的使用
```cpp
class Value {
private:
    int data_;
    
public:
    // const成员函数：不会修改对象状态
    int get_data() const { return data_; }     // 可以在const对象上调用
    
    // 非const成员函数：可能修改对象状态  
    void set_data(int data) { data_ = data; }  // 不能在const对象上调用
};

// 使用示例
const Value const_value(42);
int x = const_value.get_data();    // ✅ 可以调用const函数
// const_value.set_data(100);      // ❌ 编译错误！不能调用非const函数
```

## 2. 指针和引用

### 2.1 指针基础
```cpp
// 指针：存储内存地址的变量
Table* table_ptr = nullptr;        // 声明指针，初始化为空
table_ptr = new Table("users");    // 在堆上创建对象
table_ptr->insert_record(record);  // 通过指针调用成员函数
delete table_ptr;                  // 释放内存
table_ptr = nullptr;               // 避免悬空指针
```

### 2.2 引用基础
```cpp
// 引用：给已存在的变量起别名
Table table("users");
Table& table_ref = table;          // table_ref是table的别名

table_ref.insert_record(record);   // 等价于 table.insert_record(record)

// 函数参数中的引用
RC insert_record(const Record& record) {  // 避免拷贝，提高效率
    // record是传入参数的引用，不是拷贝
    return RC::SUCCESS;
}
```

### 2.3 指针 vs 引用
```cpp
// 指针可以重新指向其他对象
Table* ptr = &table1;
ptr = &table2;              // ✅ 可以重新指向

// 引用不能重新绑定
Table& ref = table1;
// ref = table2;            // ❌ 编译错误！引用不能重新绑定

// 指针可以为空，引用不能
Table* ptr = nullptr;       // ✅ 指针可以为空
// Table& ref = nullptr;    // ❌ 引用不能为空
```

## 3. 智能指针

### 3.1 unique_ptr - 独占所有权
```cpp
#include <memory>

// 创建智能指针
std::unique_ptr<Table> table = std::make_unique<Table>("users");

// 使用智能指针
table->insert_record(record);      // 像普通指针一样使用
(*table).insert_record(record);    // 解引用操作

// 转移所有权
std::unique_ptr<Table> another_table = std::move(table);
// 现在table为空，another_table拥有对象

// 检查是否为空
if (table) {
    cout << "table不为空" << endl;
} else {
    cout << "table为空" << endl;    // 输出这个
}
```

### 3.2 shared_ptr - 共享所有权
```cpp
// 多个指针可以共享同一个对象
std::shared_ptr<Table> table1 = std::make_shared<Table>("users");
std::shared_ptr<Table> table2 = table1;  // 共享所有权

cout << table1.use_count() << endl;  // 输出：2（有2个指针指向对象）

table1.reset();  // table1不再指向对象
cout << table2.use_count() << endl;  // 输出：1（现在只有table2指向对象）
// 当最后一个shared_ptr被销毁时，对象才会被删除
```

### 3.3 为什么使用智能指针？
```cpp
// 传统指针的问题
Table* create_table() {
    Table* table = new Table("users");
    if (some_error_condition) {
        // 忘记delete，内存泄漏！
        return nullptr;
    }
    return table;  // 调用者需要记住delete
}

// 智能指针的解决方案
std::unique_ptr<Table> create_table_safe() {
    auto table = std::make_unique<Table>("users");
    if (some_error_condition) {
        return nullptr;  // 自动释放内存
    }
    return table;  // 转移所有权，不会内存泄漏
}
```

## 4. 继承和多态

### 4.1 继承基础
```cpp
// 基类
class Expression {
protected:                          // 子类可以访问
    string name_;
    
public:
    Expression(const string& name) : name_(name) {}
    virtual ~Expression() = default; // 虚析构函数
    
    // 纯虚函数：子类必须实现
    virtual RC get_value(const Tuple& tuple, Value& value) const = 0;
    
    // 虚函数：子类可以重写
    virtual AttrType value_type() const { return AttrType::UNDEFINED; }
    
    // 普通函数：子类继承
    const string& name() const { return name_; }
};

// 派生类
class FieldExpr : public Expression {  // public继承
private:
    Field field_;
    
public:
    FieldExpr(const Field& field) : Expression("field"), field_(field) {}
    
    // 重写纯虚函数
    RC get_value(const Tuple& tuple, Value& value) const override {
        return tuple.find_cell(field_.name(), value);
    }
    
    // 重写虚函数
    AttrType value_type() const override {
        return field_.attr_type();
    }
};
```

### 4.2 多态机制
```cpp
// 多态：同一接口，不同行为
void process_expression(const Expression& expr, const Tuple& tuple) {
    Value result;
    RC rc = expr.get_value(tuple, result);  // 多态调用
    // 具体调用哪个版本的get_value取决于expr的实际类型
}

// 使用示例
FieldExpr field_expr(field);
ValueExpr value_expr(42);

process_expression(field_expr, tuple);  // 调用FieldExpr::get_value
process_expression(value_expr, tuple);  // 调用ValueExpr::get_value
```

### 4.3 虚函数表（vtable）原理
```cpp
// 编译器为每个有虚函数的类创建虚函数表
class Base {
    virtual void func1() { cout << "Base::func1" << endl; }
    virtual void func2() { cout << "Base::func2" << endl; }
};

class Derived : public Base {
    void func1() override { cout << "Derived::func1" << endl; }
    // func2没有重写，使用基类版本
};

// 运行时多态
Base* ptr = new Derived();
ptr->func1();  // 输出：Derived::func1（查虚函数表）
ptr->func2();  // 输出：Base::func2（查虚函数表）
```

## 5. 容器和迭代器

### 5.1 vector - 动态数组
```cpp
#include <vector>

// 创建vector
std::vector<Table*> tables;
std::vector<int> numbers = {1, 2, 3, 4, 5};  // 初始化列表

// 添加元素
tables.push_back(new Table("users"));
tables.push_back(new Table("orders"));

// 访问元素
Table* first_table = tables[0];        // 下标访问
Table* first_table2 = tables.at(0);    // 安全访问（会检查边界）

// 遍历
for (size_t i = 0; i < tables.size(); i++) {
    cout << tables[i]->name() << endl;
}

// 范围for循环（C++11）
for (Table* table : tables) {
    cout << table->name() << endl;
}
```

### 5.2 map - 键值对容器
```cpp
#include <map>

// 创建map
std::map<string, Table*> table_map;

// 插入元素
table_map["users"] = new Table("users");
table_map["orders"] = new Table("orders");

// 查找元素
auto it = table_map.find("users");
if (it != table_map.end()) {
    Table* table = it->second;  // 找到了
    cout << "找到表：" << table->name() << endl;
} else {
    cout << "没找到表" << endl;
}

// 遍历map
for (const auto& pair : table_map) {  // auto自动推导类型
    cout << "表名：" << pair.first << endl;      // 键
    cout << "表对象：" << pair.second << endl;   // 值
}
```

### 5.3 迭代器
```cpp
// 迭代器：访问容器元素的统一方式
std::vector<int> numbers = {1, 2, 3, 4, 5};

// 使用迭代器遍历
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
    cout << *it << " ";  // 解引用迭代器获取值
}

// 常量迭代器
for (auto it = numbers.cbegin(); it != numbers.cend(); ++it) {
    // *it = 10;  // 错误！不能修改
    cout << *it << " ";
}
```

## 6. 模板基础

### 6.1 函数模板
```cpp
// 模板函数：适用于多种类型
template<typename T>
void swap_values(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

// 使用
int x = 1, y = 2;
swap_values(x, y);        // T被推导为int

string s1 = "hello", s2 = "world";
swap_values(s1, s2);      // T被推导为string
```

### 6.2 类模板
```cpp
// 模板类
template<typename T>
class Container {
private:
    T* data_;
    size_t size_;
    
public:
    Container(size_t size) : size_(size) {
        data_ = new T[size];
    }
    
    ~Container() {
        delete[] data_;
    }
    
    T& operator[](size_t index) {
        return data_[index];
    }
};

// 使用
Container<int> int_container(10);      // T = int
Container<string> string_container(5); // T = string
```

## 7. 异常处理

### 7.1 基本异常处理
```cpp
#include <stdexcept>

// 抛出异常
RC open_file(const string& filename) {
    if (filename.empty()) {
        throw std::invalid_argument("文件名不能为空");
    }
    
    // 尝试打开文件
    if (/* 打开失败 */) {
        throw std::runtime_error("无法打开文件：" + filename);
    }
    
    return RC::SUCCESS;
}

// 捕获异常
try {
    open_file("");
} catch (const std::invalid_argument& e) {
    cout << "参数错误：" << e.what() << endl;
} catch (const std::runtime_error& e) {
    cout << "运行时错误：" << e.what() << endl;
} catch (...) {  // 捕获所有其他异常
    cout << "未知错误" << endl;
}
```

### 7.2 RAII（资源获取即初始化）
```cpp
class FileHandler {
private:
    FILE* file_;
    
public:
    FileHandler(const string& filename) {
        file_ = fopen(filename.c_str(), "r");
        if (!file_) {
            throw std::runtime_error("无法打开文件");
        }
    }
    
    ~FileHandler() {
        if (file_) {
            fclose(file_);  // 自动关闭文件
        }
    }
    
    // 禁止拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
};

// 使用RAII
void process_file(const string& filename) {
    FileHandler handler(filename);  // 构造时打开文件
    // 使用文件...
    // 函数结束时自动关闭文件（析构函数）
}
```

## 8. 现代C++特性

### 8.1 auto关键字
```cpp
// auto：自动类型推导
auto x = 42;                    // x是int
auto y = 3.14;                  // y是double
auto s = string("hello");       // s是string

// 复杂类型的简化
std::map<string, std::vector<int>> complex_map;
auto it = complex_map.begin();  // 避免写复杂的类型名

// 函数返回类型推导
auto create_table() -> std::unique_ptr<Table> {
    return std::make_unique<Table>("users");
}
```

### 8.2 范围for循环
```cpp
std::vector<string> names = {"Alice", "Bob", "Charlie"};

// 传统for循环
for (size_t i = 0; i < names.size(); i++) {
    cout << names[i] << endl;
}

// 范围for循环
for (const auto& name : names) {  // const引用，避免拷贝
    cout << name << endl;
}

// 修改元素
for (auto& name : names) {        // 非const引用，可以修改
    name += "_modified";
}
```

### 8.3 lambda表达式
```cpp
// lambda：匿名函数
auto add = [](int a, int b) -> int {
    return a + b;
};

int result = add(3, 4);  // result = 7

// 捕获外部变量
int multiplier = 10;
auto multiply = [multiplier](int x) {  // 按值捕获
    return x * multiplier;
};

auto multiply2 = [&multiplier](int x) {  // 按引用捕获
    return x * multiplier;
};

// 在STL算法中使用
std::vector<int> numbers = {1, 2, 3, 4, 5};
std::for_each(numbers.begin(), numbers.end(), [](int& n) {
    n *= 2;  // 每个元素乘以2
});
```

### 8.4 nullptr
```cpp
// C++11之前
Table* table = NULL;        // NULL实际上是0

// C++11之后
Table* table = nullptr;     // 真正的空指针

// nullptr的优势
void func(int x) { cout << "int版本" << endl; }
void func(Table* ptr) { cout << "指针版本" << endl; }

func(NULL);        // 可能调用int版本（因为NULL是0）
func(nullptr);     // 明确调用指针版本
```

## 🎓 学习建议

1. **不要试图一次学完所有语法**，遇到不懂的再查阅
2. **在实际代码中学习**，看到语法就回来查这个指南
3. **多写代码**，语法只有用了才能真正掌握
4. **关注现代C++特性**，它们让代码更安全、更简洁

## 🔗 相关资源

- [C++ Reference](https://en.cppreference.com/) - 权威语法参考
- [Effective Modern C++](https://www.oreilly.com/library/view/effective-modern-c/9781491908419/) - 现代C++最佳实践
- 项目中的实际代码 - 最好的学习材料

现在你有了C++语法基础，可以更好地理解MiniOB的代码了！
