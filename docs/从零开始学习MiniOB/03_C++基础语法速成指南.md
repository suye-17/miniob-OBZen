# C++åŸºç¡€è¯­æ³•é€ŸæˆæŒ‡å— - ä¸“ä¸ºMiniOBå­¦ä¹ å®šåˆ¶

## ğŸ¯ å­¦ä¹ ç›®æ ‡

è¿™ä¸ªæŒ‡å—ä¸“é—¨é’ˆå¯¹å­¦ä¹ MiniOBé¡¹ç›®ï¼Œæ¶µç›–é¡¹ç›®ä¸­ç”¨åˆ°çš„æ‰€æœ‰é‡è¦C++è¯­æ³•ï¼Œè®©ä½ èƒ½å¤Ÿé¡ºåˆ©é˜…è¯»å’Œç†è§£ä»£ç ã€‚

## ğŸ“š ç›®å½•

1. [ç±»å’Œå¯¹è±¡åŸºç¡€](#1-ç±»å’Œå¯¹è±¡åŸºç¡€)
2. [æŒ‡é’ˆå’Œå¼•ç”¨](#2-æŒ‡é’ˆå’Œå¼•ç”¨)
3. [æ™ºèƒ½æŒ‡é’ˆ](#3-æ™ºèƒ½æŒ‡é’ˆ)
4. [ç»§æ‰¿å’Œå¤šæ€](#4-ç»§æ‰¿å’Œå¤šæ€)
5. [å®¹å™¨å’Œè¿­ä»£å™¨](#5-å®¹å™¨å’Œè¿­ä»£å™¨)
6. [æ¨¡æ¿åŸºç¡€](#6-æ¨¡æ¿åŸºç¡€)
7. [å¼‚å¸¸å¤„ç†](#7-å¼‚å¸¸å¤„ç†)
8. [ç°ä»£C++ç‰¹æ€§](#8-ç°ä»£cç‰¹æ€§)

## 1. ç±»å’Œå¯¹è±¡åŸºç¡€

### 1.1 åŸºæœ¬ç±»å®šä¹‰
```cpp
// åœ¨MiniOBä¸­çš„ä¾‹å­ï¼šTableç±»
class Table {
private:                    // ç§æœ‰æˆå‘˜ï¼Œå¤–éƒ¨ä¸èƒ½ç›´æ¥è®¿é—®
    string name_;          // æˆå‘˜å˜é‡ï¼ˆè¡¨åï¼‰
    int record_count_;     // æˆå‘˜å˜é‡ï¼ˆè®°å½•æ•°ï¼‰
    
public:                    // å…¬æœ‰æˆå‘˜ï¼Œå¤–éƒ¨å¯ä»¥è®¿é—®
    Table();               // é»˜è®¤æ„é€ å‡½æ•°
    Table(const string& name);  // å¸¦å‚æ•°çš„æ„é€ å‡½æ•°
    ~Table();              // ææ„å‡½æ•°
    
    // æˆå‘˜å‡½æ•°
    RC insert_record(const Record& record);
    RC delete_record(const RID& rid);
    
    // getterå’Œsetter
    const string& name() const { return name_; }  // å†…è”å‡½æ•°
    void set_name(const string& name) { name_ = name; }
};
```

### 1.2 æ„é€ å‡½æ•°å’Œææ„å‡½æ•°
```cpp
// æ„é€ å‡½æ•°ï¼šåˆ›å»ºå¯¹è±¡æ—¶è‡ªåŠ¨è°ƒç”¨
Table::Table() : name_(""), record_count_(0) {  // åˆå§‹åŒ–åˆ—è¡¨
    cout << "åˆ›å»ºäº†ä¸€ä¸ªç©ºè¡¨" << endl;
}

Table::Table(const string& name) : name_(name), record_count_(0) {
    cout << "åˆ›å»ºäº†è¡¨ï¼š" << name << endl;
}

// ææ„å‡½æ•°ï¼šå¯¹è±¡é”€æ¯æ—¶è‡ªåŠ¨è°ƒç”¨
Table::~Table() {
    cout << "é”€æ¯è¡¨ï¼š" << name_ << endl;
    // é‡Šæ”¾èµ„æºï¼Œå…³é—­æ–‡ä»¶ç­‰
}

// ä½¿ç”¨ç¤ºä¾‹
Table students_table("students");  // è°ƒç”¨å¸¦å‚æ„é€ å‡½æ•°
// å‡½æ•°ç»“æŸæ—¶è‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°
```

### 1.3 constå…³é”®å­—çš„ä½¿ç”¨
```cpp
class Value {
private:
    int data_;
    
public:
    // constæˆå‘˜å‡½æ•°ï¼šä¸ä¼šä¿®æ”¹å¯¹è±¡çŠ¶æ€
    int get_data() const { return data_; }     // å¯ä»¥åœ¨constå¯¹è±¡ä¸Šè°ƒç”¨
    
    // éconstæˆå‘˜å‡½æ•°ï¼šå¯èƒ½ä¿®æ”¹å¯¹è±¡çŠ¶æ€  
    void set_data(int data) { data_ = data; }  // ä¸èƒ½åœ¨constå¯¹è±¡ä¸Šè°ƒç”¨
};

// ä½¿ç”¨ç¤ºä¾‹
const Value const_value(42);
int x = const_value.get_data();    // âœ… å¯ä»¥è°ƒç”¨constå‡½æ•°
// const_value.set_data(100);      // âŒ ç¼–è¯‘é”™è¯¯ï¼ä¸èƒ½è°ƒç”¨éconstå‡½æ•°
```

## 2. æŒ‡é’ˆå’Œå¼•ç”¨

### 2.1 æŒ‡é’ˆåŸºç¡€
```cpp
// æŒ‡é’ˆï¼šå­˜å‚¨å†…å­˜åœ°å€çš„å˜é‡
Table* table_ptr = nullptr;        // å£°æ˜æŒ‡é’ˆï¼Œåˆå§‹åŒ–ä¸ºç©º
table_ptr = new Table("users");    // åœ¨å †ä¸Šåˆ›å»ºå¯¹è±¡
table_ptr->insert_record(record);  // é€šè¿‡æŒ‡é’ˆè°ƒç”¨æˆå‘˜å‡½æ•°
delete table_ptr;                  // é‡Šæ”¾å†…å­˜
table_ptr = nullptr;               // é¿å…æ‚¬ç©ºæŒ‡é’ˆ
```

### 2.2 å¼•ç”¨åŸºç¡€
```cpp
// å¼•ç”¨ï¼šç»™å·²å­˜åœ¨çš„å˜é‡èµ·åˆ«å
Table table("users");
Table& table_ref = table;          // table_refæ˜¯tableçš„åˆ«å

table_ref.insert_record(record);   // ç­‰ä»·äº table.insert_record(record)

// å‡½æ•°å‚æ•°ä¸­çš„å¼•ç”¨
RC insert_record(const Record& record) {  // é¿å…æ‹·è´ï¼Œæé«˜æ•ˆç‡
    // recordæ˜¯ä¼ å…¥å‚æ•°çš„å¼•ç”¨ï¼Œä¸æ˜¯æ‹·è´
    return RC::SUCCESS;
}
```

### 2.3 æŒ‡é’ˆ vs å¼•ç”¨
```cpp
// æŒ‡é’ˆå¯ä»¥é‡æ–°æŒ‡å‘å…¶ä»–å¯¹è±¡
Table* ptr = &table1;
ptr = &table2;              // âœ… å¯ä»¥é‡æ–°æŒ‡å‘

// å¼•ç”¨ä¸èƒ½é‡æ–°ç»‘å®š
Table& ref = table1;
// ref = table2;            // âŒ ç¼–è¯‘é”™è¯¯ï¼å¼•ç”¨ä¸èƒ½é‡æ–°ç»‘å®š

// æŒ‡é’ˆå¯ä»¥ä¸ºç©ºï¼Œå¼•ç”¨ä¸èƒ½
Table* ptr = nullptr;       // âœ… æŒ‡é’ˆå¯ä»¥ä¸ºç©º
// Table& ref = nullptr;    // âŒ å¼•ç”¨ä¸èƒ½ä¸ºç©º
```

## 3. æ™ºèƒ½æŒ‡é’ˆ

### 3.1 unique_ptr - ç‹¬å æ‰€æœ‰æƒ
```cpp
#include <memory>

// åˆ›å»ºæ™ºèƒ½æŒ‡é’ˆ
std::unique_ptr<Table> table = std::make_unique<Table>("users");

// ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
table->insert_record(record);      // åƒæ™®é€šæŒ‡é’ˆä¸€æ ·ä½¿ç”¨
(*table).insert_record(record);    // è§£å¼•ç”¨æ“ä½œ

// è½¬ç§»æ‰€æœ‰æƒ
std::unique_ptr<Table> another_table = std::move(table);
// ç°åœ¨tableä¸ºç©ºï¼Œanother_tableæ‹¥æœ‰å¯¹è±¡

// æ£€æŸ¥æ˜¯å¦ä¸ºç©º
if (table) {
    cout << "tableä¸ä¸ºç©º" << endl;
} else {
    cout << "tableä¸ºç©º" << endl;    // è¾“å‡ºè¿™ä¸ª
}
```

### 3.2 shared_ptr - å…±äº«æ‰€æœ‰æƒ
```cpp
// å¤šä¸ªæŒ‡é’ˆå¯ä»¥å…±äº«åŒä¸€ä¸ªå¯¹è±¡
std::shared_ptr<Table> table1 = std::make_shared<Table>("users");
std::shared_ptr<Table> table2 = table1;  // å…±äº«æ‰€æœ‰æƒ

cout << table1.use_count() << endl;  // è¾“å‡ºï¼š2ï¼ˆæœ‰2ä¸ªæŒ‡é’ˆæŒ‡å‘å¯¹è±¡ï¼‰

table1.reset();  // table1ä¸å†æŒ‡å‘å¯¹è±¡
cout << table2.use_count() << endl;  // è¾“å‡ºï¼š1ï¼ˆç°åœ¨åªæœ‰table2æŒ‡å‘å¯¹è±¡ï¼‰
// å½“æœ€åä¸€ä¸ªshared_ptrè¢«é”€æ¯æ—¶ï¼Œå¯¹è±¡æ‰ä¼šè¢«åˆ é™¤
```

### 3.3 ä¸ºä»€ä¹ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Ÿ
```cpp
// ä¼ ç»ŸæŒ‡é’ˆçš„é—®é¢˜
Table* create_table() {
    Table* table = new Table("users");
    if (some_error_condition) {
        // å¿˜è®°deleteï¼Œå†…å­˜æ³„æ¼ï¼
        return nullptr;
    }
    return table;  // è°ƒç”¨è€…éœ€è¦è®°ä½delete
}

// æ™ºèƒ½æŒ‡é’ˆçš„è§£å†³æ–¹æ¡ˆ
std::unique_ptr<Table> create_table_safe() {
    auto table = std::make_unique<Table>("users");
    if (some_error_condition) {
        return nullptr;  // è‡ªåŠ¨é‡Šæ”¾å†…å­˜
    }
    return table;  // è½¬ç§»æ‰€æœ‰æƒï¼Œä¸ä¼šå†…å­˜æ³„æ¼
}
```

## 4. ç»§æ‰¿å’Œå¤šæ€

### 4.1 ç»§æ‰¿åŸºç¡€
```cpp
// åŸºç±»
class Expression {
protected:                          // å­ç±»å¯ä»¥è®¿é—®
    string name_;
    
public:
    Expression(const string& name) : name_(name) {}
    virtual ~Expression() = default; // è™šææ„å‡½æ•°
    
    // çº¯è™šå‡½æ•°ï¼šå­ç±»å¿…é¡»å®ç°
    virtual RC get_value(const Tuple& tuple, Value& value) const = 0;
    
    // è™šå‡½æ•°ï¼šå­ç±»å¯ä»¥é‡å†™
    virtual AttrType value_type() const { return AttrType::UNDEFINED; }
    
    // æ™®é€šå‡½æ•°ï¼šå­ç±»ç»§æ‰¿
    const string& name() const { return name_; }
};

// æ´¾ç”Ÿç±»
class FieldExpr : public Expression {  // publicç»§æ‰¿
private:
    Field field_;
    
public:
    FieldExpr(const Field& field) : Expression("field"), field_(field) {}
    
    // é‡å†™çº¯è™šå‡½æ•°
    RC get_value(const Tuple& tuple, Value& value) const override {
        return tuple.find_cell(field_.name(), value);
    }
    
    // é‡å†™è™šå‡½æ•°
    AttrType value_type() const override {
        return field_.attr_type();
    }
};
```

### 4.2 å¤šæ€æœºåˆ¶
```cpp
// å¤šæ€ï¼šåŒä¸€æ¥å£ï¼Œä¸åŒè¡Œä¸º
void process_expression(const Expression& expr, const Tuple& tuple) {
    Value result;
    RC rc = expr.get_value(tuple, result);  // å¤šæ€è°ƒç”¨
    // å…·ä½“è°ƒç”¨å“ªä¸ªç‰ˆæœ¬çš„get_valueå–å†³äºexprçš„å®é™…ç±»å‹
}

// ä½¿ç”¨ç¤ºä¾‹
FieldExpr field_expr(field);
ValueExpr value_expr(42);

process_expression(field_expr, tuple);  // è°ƒç”¨FieldExpr::get_value
process_expression(value_expr, tuple);  // è°ƒç”¨ValueExpr::get_value
```

### 4.3 è™šå‡½æ•°è¡¨ï¼ˆvtableï¼‰åŸç†
```cpp
// ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªæœ‰è™šå‡½æ•°çš„ç±»åˆ›å»ºè™šå‡½æ•°è¡¨
class Base {
    virtual void func1() { cout << "Base::func1" << endl; }
    virtual void func2() { cout << "Base::func2" << endl; }
};

class Derived : public Base {
    void func1() override { cout << "Derived::func1" << endl; }
    // func2æ²¡æœ‰é‡å†™ï¼Œä½¿ç”¨åŸºç±»ç‰ˆæœ¬
};

// è¿è¡Œæ—¶å¤šæ€
Base* ptr = new Derived();
ptr->func1();  // è¾“å‡ºï¼šDerived::func1ï¼ˆæŸ¥è™šå‡½æ•°è¡¨ï¼‰
ptr->func2();  // è¾“å‡ºï¼šBase::func2ï¼ˆæŸ¥è™šå‡½æ•°è¡¨ï¼‰
```

## 5. å®¹å™¨å’Œè¿­ä»£å™¨

### 5.1 vector - åŠ¨æ€æ•°ç»„
```cpp
#include <vector>

// åˆ›å»ºvector
std::vector<Table*> tables;
std::vector<int> numbers = {1, 2, 3, 4, 5};  // åˆå§‹åŒ–åˆ—è¡¨

// æ·»åŠ å…ƒç´ 
tables.push_back(new Table("users"));
tables.push_back(new Table("orders"));

// è®¿é—®å…ƒç´ 
Table* first_table = tables[0];        // ä¸‹æ ‡è®¿é—®
Table* first_table2 = tables.at(0);    // å®‰å…¨è®¿é—®ï¼ˆä¼šæ£€æŸ¥è¾¹ç•Œï¼‰

// éå†
for (size_t i = 0; i < tables.size(); i++) {
    cout << tables[i]->name() << endl;
}

// èŒƒå›´forå¾ªç¯ï¼ˆC++11ï¼‰
for (Table* table : tables) {
    cout << table->name() << endl;
}
```

### 5.2 map - é”®å€¼å¯¹å®¹å™¨
```cpp
#include <map>

// åˆ›å»ºmap
std::map<string, Table*> table_map;

// æ’å…¥å…ƒç´ 
table_map["users"] = new Table("users");
table_map["orders"] = new Table("orders");

// æŸ¥æ‰¾å…ƒç´ 
auto it = table_map.find("users");
if (it != table_map.end()) {
    Table* table = it->second;  // æ‰¾åˆ°äº†
    cout << "æ‰¾åˆ°è¡¨ï¼š" << table->name() << endl;
} else {
    cout << "æ²¡æ‰¾åˆ°è¡¨" << endl;
}

// éå†map
for (const auto& pair : table_map) {  // autoè‡ªåŠ¨æ¨å¯¼ç±»å‹
    cout << "è¡¨åï¼š" << pair.first << endl;      // é”®
    cout << "è¡¨å¯¹è±¡ï¼š" << pair.second << endl;   // å€¼
}
```

### 5.3 è¿­ä»£å™¨
```cpp
// è¿­ä»£å™¨ï¼šè®¿é—®å®¹å™¨å…ƒç´ çš„ç»Ÿä¸€æ–¹å¼
std::vector<int> numbers = {1, 2, 3, 4, 5};

// ä½¿ç”¨è¿­ä»£å™¨éå†
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
    cout << *it << " ";  // è§£å¼•ç”¨è¿­ä»£å™¨è·å–å€¼
}

// å¸¸é‡è¿­ä»£å™¨
for (auto it = numbers.cbegin(); it != numbers.cend(); ++it) {
    // *it = 10;  // é”™è¯¯ï¼ä¸èƒ½ä¿®æ”¹
    cout << *it << " ";
}
```

## 6. æ¨¡æ¿åŸºç¡€

### 6.1 å‡½æ•°æ¨¡æ¿
```cpp
// æ¨¡æ¿å‡½æ•°ï¼šé€‚ç”¨äºå¤šç§ç±»å‹
template<typename T>
void swap_values(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

// ä½¿ç”¨
int x = 1, y = 2;
swap_values(x, y);        // Tè¢«æ¨å¯¼ä¸ºint

string s1 = "hello", s2 = "world";
swap_values(s1, s2);      // Tè¢«æ¨å¯¼ä¸ºstring
```

### 6.2 ç±»æ¨¡æ¿
```cpp
// æ¨¡æ¿ç±»
template<typename T>
class Container {
private:
    T* data_;
    size_t size_;
    
public:
    Container(size_t size) : size_(size) {
        data_ = new T[size];
    }
    
    ~Container() {
        delete[] data_;
    }
    
    T& operator[](size_t index) {
        return data_[index];
    }
};

// ä½¿ç”¨
Container<int> int_container(10);      // T = int
Container<string> string_container(5); // T = string
```

## 7. å¼‚å¸¸å¤„ç†

### 7.1 åŸºæœ¬å¼‚å¸¸å¤„ç†
```cpp
#include <stdexcept>

// æŠ›å‡ºå¼‚å¸¸
RC open_file(const string& filename) {
    if (filename.empty()) {
        throw std::invalid_argument("æ–‡ä»¶åä¸èƒ½ä¸ºç©º");
    }
    
    // å°è¯•æ‰“å¼€æ–‡ä»¶
    if (/* æ‰“å¼€å¤±è´¥ */) {
        throw std::runtime_error("æ— æ³•æ‰“å¼€æ–‡ä»¶ï¼š" + filename);
    }
    
    return RC::SUCCESS;
}

// æ•è·å¼‚å¸¸
try {
    open_file("");
} catch (const std::invalid_argument& e) {
    cout << "å‚æ•°é”™è¯¯ï¼š" << e.what() << endl;
} catch (const std::runtime_error& e) {
    cout << "è¿è¡Œæ—¶é”™è¯¯ï¼š" << e.what() << endl;
} catch (...) {  // æ•è·æ‰€æœ‰å…¶ä»–å¼‚å¸¸
    cout << "æœªçŸ¥é”™è¯¯" << endl;
}
```

### 7.2 RAIIï¼ˆèµ„æºè·å–å³åˆå§‹åŒ–ï¼‰
```cpp
class FileHandler {
private:
    FILE* file_;
    
public:
    FileHandler(const string& filename) {
        file_ = fopen(filename.c_str(), "r");
        if (!file_) {
            throw std::runtime_error("æ— æ³•æ‰“å¼€æ–‡ä»¶");
        }
    }
    
    ~FileHandler() {
        if (file_) {
            fclose(file_);  // è‡ªåŠ¨å…³é—­æ–‡ä»¶
        }
    }
    
    // ç¦æ­¢æ‹·è´
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
};

// ä½¿ç”¨RAII
void process_file(const string& filename) {
    FileHandler handler(filename);  // æ„é€ æ—¶æ‰“å¼€æ–‡ä»¶
    // ä½¿ç”¨æ–‡ä»¶...
    // å‡½æ•°ç»“æŸæ—¶è‡ªåŠ¨å…³é—­æ–‡ä»¶ï¼ˆææ„å‡½æ•°ï¼‰
}
```

## 8. ç°ä»£C++ç‰¹æ€§

### 8.1 autoå…³é”®å­—
```cpp
// autoï¼šè‡ªåŠ¨ç±»å‹æ¨å¯¼
auto x = 42;                    // xæ˜¯int
auto y = 3.14;                  // yæ˜¯double
auto s = string("hello");       // sæ˜¯string

// å¤æ‚ç±»å‹çš„ç®€åŒ–
std::map<string, std::vector<int>> complex_map;
auto it = complex_map.begin();  // é¿å…å†™å¤æ‚çš„ç±»å‹å

// å‡½æ•°è¿”å›ç±»å‹æ¨å¯¼
auto create_table() -> std::unique_ptr<Table> {
    return std::make_unique<Table>("users");
}
```

### 8.2 èŒƒå›´forå¾ªç¯
```cpp
std::vector<string> names = {"Alice", "Bob", "Charlie"};

// ä¼ ç»Ÿforå¾ªç¯
for (size_t i = 0; i < names.size(); i++) {
    cout << names[i] << endl;
}

// èŒƒå›´forå¾ªç¯
for (const auto& name : names) {  // constå¼•ç”¨ï¼Œé¿å…æ‹·è´
    cout << name << endl;
}

// ä¿®æ”¹å…ƒç´ 
for (auto& name : names) {        // éconstå¼•ç”¨ï¼Œå¯ä»¥ä¿®æ”¹
    name += "_modified";
}
```

### 8.3 lambdaè¡¨è¾¾å¼
```cpp
// lambdaï¼šåŒ¿åå‡½æ•°
auto add = [](int a, int b) -> int {
    return a + b;
};

int result = add(3, 4);  // result = 7

// æ•è·å¤–éƒ¨å˜é‡
int multiplier = 10;
auto multiply = [multiplier](int x) {  // æŒ‰å€¼æ•è·
    return x * multiplier;
};

auto multiply2 = [&multiplier](int x) {  // æŒ‰å¼•ç”¨æ•è·
    return x * multiplier;
};

// åœ¨STLç®—æ³•ä¸­ä½¿ç”¨
std::vector<int> numbers = {1, 2, 3, 4, 5};
std::for_each(numbers.begin(), numbers.end(), [](int& n) {
    n *= 2;  // æ¯ä¸ªå…ƒç´ ä¹˜ä»¥2
});
```

### 8.4 nullptr
```cpp
// C++11ä¹‹å‰
Table* table = NULL;        // NULLå®é™…ä¸Šæ˜¯0

// C++11ä¹‹å
Table* table = nullptr;     // çœŸæ­£çš„ç©ºæŒ‡é’ˆ

// nullptrçš„ä¼˜åŠ¿
void func(int x) { cout << "intç‰ˆæœ¬" << endl; }
void func(Table* ptr) { cout << "æŒ‡é’ˆç‰ˆæœ¬" << endl; }

func(NULL);        // å¯èƒ½è°ƒç”¨intç‰ˆæœ¬ï¼ˆå› ä¸ºNULLæ˜¯0ï¼‰
func(nullptr);     // æ˜ç¡®è°ƒç”¨æŒ‡é’ˆç‰ˆæœ¬
```

## ğŸ“ å­¦ä¹ å»ºè®®

1. **ä¸è¦è¯•å›¾ä¸€æ¬¡å­¦å®Œæ‰€æœ‰è¯­æ³•**ï¼Œé‡åˆ°ä¸æ‡‚çš„å†æŸ¥é˜…
2. **åœ¨å®é™…ä»£ç ä¸­å­¦ä¹ **ï¼Œçœ‹åˆ°è¯­æ³•å°±å›æ¥æŸ¥è¿™ä¸ªæŒ‡å—
3. **å¤šå†™ä»£ç **ï¼Œè¯­æ³•åªæœ‰ç”¨äº†æ‰èƒ½çœŸæ­£æŒæ¡
4. **å…³æ³¨ç°ä»£C++ç‰¹æ€§**ï¼Œå®ƒä»¬è®©ä»£ç æ›´å®‰å…¨ã€æ›´ç®€æ´

## ğŸ”— ç›¸å…³èµ„æº

- [C++ Reference](https://en.cppreference.com/) - æƒå¨è¯­æ³•å‚è€ƒ
- [Effective Modern C++](https://www.oreilly.com/library/view/effective-modern-c/9781491908419/) - ç°ä»£C++æœ€ä½³å®è·µ
- é¡¹ç›®ä¸­çš„å®é™…ä»£ç  - æœ€å¥½çš„å­¦ä¹ ææ–™

ç°åœ¨ä½ æœ‰äº†C++è¯­æ³•åŸºç¡€ï¼Œå¯ä»¥æ›´å¥½åœ°ç†è§£MiniOBçš„ä»£ç äº†ï¼
