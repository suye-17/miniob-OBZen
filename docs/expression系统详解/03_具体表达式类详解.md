# 具体表达式类详解 - 从简单到复杂

## 1. StarExpr - 星号表达式（最简单）

### 1.1 代码分析
```cpp
class StarExpr : public Expression
{
public:
  StarExpr() : table_name_() {}                    // 默认构造：空表名
  StarExpr(const char *table_name) : table_name_(table_name) {}  // 指定表名
  virtual ~StarExpr() = default;                   // 默认析构

  unique_ptr<Expression> copy() const override { 
    return make_unique<StarExpr>(table_name_.c_str()); 
  }

  ExprType type() const override { return ExprType::STAR; }
  AttrType value_type() const override { return AttrType::UNDEFINED; }

  RC get_value(const Tuple &tuple, Value &value) const override { 
    return RC::UNIMPLEMENTED;  // 不需要实现
  }

  const char *table_name() const { return table_name_.c_str(); }

private:
  string table_name_;  // 可能的表名限定
};
```

### 1.2 用途和特点
```sql
-- 对应的SQL语句
SELECT * FROM students;           -- StarExpr()
SELECT students.* FROM students;  -- StarExpr("students")
```

**关键点：**
- `get_value()` 返回 `RC::UNIMPLEMENTED` 因为星号不代表具体值
- 在查询规划阶段会被展开为具体的字段列表
- `table_name_` 用于处理多表查询中的表限定

### 1.3 C++语法学习点
```cpp
// 构造函数初始化列表
StarExpr(const char *table_name) : table_name_(table_name) {}
//                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
//                                 这是初始化列表，直接初始化成员变量

// 等价于（但效率更低）：
StarExpr(const char *table_name) {
    table_name_ = table_name;  // 先默认构造，再赋值
}
```

## 2. ValueExpr - 常量值表达式

### 2.1 代码分析
```cpp
class ValueExpr : public Expression
{
public:
  ValueExpr() = default;                           // 默认构造
  explicit ValueExpr(const Value &value) : value_(value) {}  // 从Value构造

  virtual ~ValueExpr() = default;

  bool equal(const Expression &other) const override;  // 重写相等比较

  unique_ptr<Expression> copy() const override { 
    return make_unique<ValueExpr>(value_); 
  }

  // 核心方法：直接返回存储的值
  RC get_value(const Tuple &tuple, Value &value) const override;
  RC get_column(Chunk &chunk, Column &column) override;
  
  // 编译时就能确定值
  RC try_get_value(Value &value) const override
  {
    value = value_;      // 直接复制
    return RC::SUCCESS;
  }

  ExprType type() const override { return ExprType::VALUE; }
  AttrType value_type() const override { return value_.attr_type(); }
  int      value_length() const override { return value_.length(); }

  void         get_value(Value &value) const { value = value_; }
  const Value &get_value() const { return value_; }

private:
  Value value_;  // 存储的常量值
};
```

### 2.2 使用场景
```cpp
// 创建不同类型的常量表达式
ValueExpr int_expr(Value(42));           // 整数常量
ValueExpr float_expr(Value(3.14f));      // 浮点数常量  
ValueExpr string_expr(Value("hello"));   // 字符串常量
ValueExpr bool_expr(Value(true));        // 布尔常量

// 在SQL中对应：
// SELECT 42, 3.14, 'hello', true FROM dual;
```

### 2.3 C++语法学习点

#### explicit关键字
```cpp
explicit ValueExpr(const Value &value) : value_(value) {}
```

**为什么要用explicit？**
```cpp
// 没有explicit的问题：
class ValueExpr {
public:
    ValueExpr(const Value &value) : value_(value) {}  // 没有explicit
};

void process_expr(const ValueExpr& expr) { /* ... */ }

Value v(42);
process_expr(v);  // 隐式转换！Value自动转换为ValueExpr
                  // 可能不是我们想要的行为

// 有explicit后：
explicit ValueExpr(const Value &value) : value_(value) {}

process_expr(v);           // 编译错误！
process_expr(ValueExpr(v)); // 必须显式构造，意图明确
```

#### 方法重载
```cpp
// 两个同名但不同的get_value方法
void get_value(Value &value) const { value = value_; }     // 输出参数版本
const Value &get_value() const { return value_; }         // 返回引用版本

// 使用：
ValueExpr expr(Value(42));

// 方式1：输出参数
Value result1;
expr.get_value(result1);  // 调用第一个版本

// 方式2：返回引用
const Value& result2 = expr.get_value();  // 调用第二个版本
```

## 3. FieldExpr - 字段表达式

### 3.1 代码分析
```cpp
class FieldExpr : public Expression
{
public:
  FieldExpr() = default;
  FieldExpr(const Table *table, const FieldMeta *field) : field_(table, field) {}
  FieldExpr(const Field &field) : field_(field) {}

  virtual ~FieldExpr() = default;

  bool equal(const Expression &other) const override;

  unique_ptr<Expression> copy() const override { 
    return make_unique<FieldExpr>(field_); 
  }

  ExprType type() const override { return ExprType::FIELD; }
  AttrType value_type() const override { return field_.attr_type(); }
  int      value_length() const override { return field_.meta()->len(); }

  Field &field() { return field_; }                    // 非const版本
  const Field &field() const { return field_; }       // const版本

  const char *table_name() const { return field_.table_name(); }
  const char *field_name() const { return field_.field_name(); }

  RC get_column(Chunk &chunk, Column &column) override;
  RC get_value(const Tuple &tuple, Value &value) const override;

private:
  Field field_;  // 字段信息（表+字段元数据）
};
```

### 3.2 Field类的作用
```cpp
// Field类封装了字段的完整信息
class Field {
    const Table* table_;       // 所属表
    const FieldMeta* meta_;    // 字段元数据（类型、长度、偏移等）
public:
    const char* table_name() const;
    const char* field_name() const;
    AttrType attr_type() const;
    // ... 其他方法
};
```

### 3.3 get_value实现原理
```cpp
// 在expression.cpp中的实现
RC FieldExpr::get_value(const Tuple &tuple, Value &value) const
{
  // 通过表名和字段名在tuple中查找对应的值
  return tuple.find_cell(TupleCellSpec(table_name(), field_name()), value);
}
```

**工作流程：**
1. 根据表名和字段名创建`TupleCellSpec`（字段规格）
2. 在`tuple`中查找匹配的cell
3. 将找到的值复制到输出参数`value`中

### 3.4 使用示例
```cpp
// 假设有表students(id, name, age)
Table* students_table = /* ... */;
const FieldMeta* age_field = students_table->table_meta().field("age");

// 创建字段表达式
FieldExpr age_expr(students_table, age_field);

// 假设有一行数据：{1, "张三", 20}
RowTuple tuple;
tuple.add_cell(TupleCell(1));
tuple.add_cell(TupleCell("张三"));
tuple.add_cell(TupleCell(20));

// 获取age字段的值
Value age_value;
RC rc = age_expr.get_value(tuple, age_value);  // age_value = 20
```

## 4. UnboundFieldExpr - 未绑定字段表达式

### 4.1 代码分析
```cpp
class UnboundFieldExpr : public Expression
{
public:
  UnboundFieldExpr(const string &table_name, const string &field_name)
      : table_name_(table_name), field_name_(field_name)
  {}

  virtual ~UnboundFieldExpr() = default;

  unique_ptr<Expression> copy() const override { 
    return make_unique<UnboundFieldExpr>(table_name_, field_name_); 
  }

  ExprType type() const override { return ExprType::UNBOUND_FIELD; }
  AttrType value_type() const override { return AttrType::UNDEFINED; }

  RC get_value(const Tuple &tuple, Value &value) const override { 
    return RC::INTERNAL;  // 不应该被调用
  }

  const char *table_name() const { return table_name_.c_str(); }
  const char *field_name() const { return field_name_.c_str(); }

private:
  string table_name_;  // 表名（可能为空）
  string field_name_;  // 字段名
};
```

### 4.2 存在的意义
```cpp
// SQL解析阶段：只有字符串信息
"SELECT name, age FROM students WHERE age > 18"

// 1. 解析器创建UnboundFieldExpr
auto name_expr = make_unique<UnboundFieldExpr>("", "name");      // 表名为空
auto age_expr1 = make_unique<UnboundFieldExpr>("", "age");
auto age_expr2 = make_unique<UnboundFieldExpr>("", "age");

// 2. 绑定阶段：转换为FieldExpr
// ExpressionBinder会：
// - 查找students表
// - 找到name和age字段的元数据
// - 创建FieldExpr替换UnboundFieldExpr

auto bound_name = make_unique<FieldExpr>(students_table, name_field_meta);
auto bound_age1 = make_unique<FieldExpr>(students_table, age_field_meta);
auto bound_age2 = make_unique<FieldExpr>(students_table, age_field_meta);
```

### 4.3 为什么get_value返回RC::INTERNAL？
```cpp
RC get_value(const Tuple &tuple, Value &value) const override { 
  return RC::INTERNAL;  // 表示内部错误
}
```

**原因：**
- `UnboundFieldExpr` 是临时状态，不应该参与实际计算
- 如果执行到这里，说明绑定过程有问题
- 返回`RC::INTERNAL`帮助调试和错误定位

## 5. 设计模式分析

### 5.1 状态模式
```cpp
// UnboundFieldExpr -> FieldExpr 体现了状态转换
class FieldReference {
    enum State { UNBOUND, BOUND };
    State state_;
    
    // 根据状态有不同行为
    RC get_value(...) {
        switch(state_) {
            case UNBOUND: return RC::INTERNAL;     // 错误
            case BOUND: return actual_get_value(); // 正常计算
        }
    }
};
```

### 5.2 工厂模式的影子
```cpp
// ExpressionBinder充当工厂，根据UnboundFieldExpr创建FieldExpr
class ExpressionBinder {
    unique_ptr<Expression> bind(unique_ptr<Expression> unbound_expr) {
        if (unbound_expr->type() == ExprType::UNBOUND_FIELD) {
            // 从UnboundFieldExpr提取信息
            auto* unbound = static_cast<UnboundFieldExpr*>(unbound_expr.get());
            
            // 查找表和字段
            Table* table = find_table(unbound->table_name());
            const FieldMeta* field = table->find_field(unbound->field_name());
            
            // 创建新的FieldExpr
            return make_unique<FieldExpr>(table, field);
        }
        return unbound_expr;  // 其他类型直接返回
    }
};
```

下一步我们来看更复杂的表达式：算术表达式和比较表达式！
