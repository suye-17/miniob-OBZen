# 表达式绑定器详解 - 从文本到对象的转换

## 1. ExpressionBinder的作用和重要性

### 1.1 什么是"绑定"？
```cpp
// SQL解析后的状态（文本信息）
"SELECT name, age FROM students WHERE age > 18"

// 解析器产生的未绑定表达式：
UnboundFieldExpr("", "name")      // 只知道字段名是"name"
UnboundFieldExpr("", "age")       // 只知道字段名是"age"  
ComparisonExpr(GREAT_THAN, 
    UnboundFieldExpr("", "age"), 
    ValueExpr(18)
)

// 绑定后的表达式（具体对象信息）：
FieldExpr(students_table, name_field_meta)    // 知道具体的表和字段元数据
FieldExpr(students_table, age_field_meta)     // 知道字段类型、长度、偏移等
ComparisonExpr(GREAT_THAN,
    FieldExpr(students_table, age_field_meta),
    ValueExpr(18)
)
```

**绑定过程的核心任务：**
1. **字段解析：** 将字段名转换为具体的Field对象
2. **类型检查：** 验证表达式的类型兼容性
3. **错误检测：** 发现不存在的字段、表等错误
4. **优化准备：** 为后续优化器提供完整的元数据信息

### 1.2 文件结构分析
- **头文件：** `src/observer/sql/parser/expression_binder.h`
- **实现文件：** `src/observer/sql/parser/expression_binder.cpp`
- **核心类：** `ExpressionBinder` 和 `BinderContext`

## 2. BinderContext - 绑定上下文

### 2.1 类结构分析
```cpp
class BinderContext
{
public:
  BinderContext()          = default;
  virtual ~BinderContext() = default;

  void add_table(Table *table) { query_tables_.push_back(table); }

  Table *find_table(const char *table_name) const;

  const vector<Table *> &query_tables() const { return query_tables_; }

private:
  vector<Table *> query_tables_;  // 查询涉及的所有表
};
```

### 2.2 上下文的作用
```cpp
// 单表查询
// SELECT name FROM students WHERE age > 18
BinderContext context;
context.add_table(students_table);  // 只有一个表

// 多表查询  
// SELECT s.name, c.title FROM students s, courses c WHERE s.id = c.student_id
BinderContext context;
context.add_table(students_table);
context.add_table(courses_table);   // 两个表都在上下文中
```

**为什么需要上下文？**
- **字段歧义解决：** 多表中可能有同名字段
- **表名验证：** 检查表是否存在于当前查询中
- **作用域管理：** 子查询可能有不同的表作用域

### 2.3 find_table()实现原理
```cpp
Table *find_table(const char *table_name) const 
{
    if (table_name == nullptr || strlen(table_name) == 0) {
        // 没有指定表名，如果只有一个表，返回它
        if (query_tables_.size() == 1) {
            return query_tables_[0];
        }
        return nullptr;  // 多表情况下必须指定表名
    }
    
    // 按表名查找
    for (Table* table : query_tables_) {
        if (strcmp(table->name(), table_name) == 0) {
            return table;
        }
    }
    return nullptr;  // 表不存在
}
```

## 3. ExpressionBinder - 核心绑定器

### 3.1 类结构分析
```cpp
class ExpressionBinder
{
public:
  ExpressionBinder(BinderContext &context) : context_(context) {}
  virtual ~ExpressionBinder() = default;

  // 主要绑定方法
  RC bind_expression(unique_ptr<Expression> &expr, vector<unique_ptr<Expression>> &bound_expressions);

private:
  // 针对不同表达式类型的绑定方法
  RC bind_star_expression(unique_ptr<Expression> &star_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_unbound_field_expression(unique_ptr<Expression> &unbound_field_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_field_expression(unique_ptr<Expression> &field_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_value_expression(unique_ptr<Expression> &value_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_cast_expression(unique_ptr<Expression> &cast_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_comparison_expression(unique_ptr<Expression> &comparison_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_conjunction_expression(unique_ptr<Expression> &conjunction_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_arithmetic_expression(unique_ptr<Expression> &arithmetic_expr, vector<unique_ptr<Expression>> &bound_expressions);
  RC bind_aggregate_expression(unique_ptr<Expression> &aggregate_expr, vector<unique_ptr<Expression>> &bound_expressions);

private:
  BinderContext &context_;  // 绑定上下文引用
};
```

### 3.2 C++语法学习点

#### 引用参数的使用
```cpp
RC bind_expression(unique_ptr<Expression> &expr, vector<unique_ptr<Expression>> &bound_expressions);
//                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//                 输入/输出参数：会被修改        输出参数：存储绑定后的表达式列表
```

**为什么用引用？**
```cpp
// 如果用值传递（错误）
RC bind_expression(unique_ptr<Expression> expr, ...) {
    // expr是副本，修改不会影响原对象
    expr = make_unique<FieldExpr>(...);  // 只修改了副本！
}

// 使用引用传递（正确）
RC bind_expression(unique_ptr<Expression> &expr, ...) {
    // expr是原对象的引用，修改会影响原对象
    expr = make_unique<FieldExpr>(...);  // 修改了原对象！
}
```

#### 方法重载和分发
```cpp
RC bind_expression(unique_ptr<Expression> &expr, vector<unique_ptr<Expression>> &bound_expressions)
{
    switch (expr->type()) {
        case ExprType::STAR:
            return bind_star_expression(expr, bound_expressions);
        case ExprType::UNBOUND_FIELD:
            return bind_unbound_field_expression(expr, bound_expressions);
        case ExprType::FIELD:
            return bind_field_expression(expr, bound_expressions);
        case ExprType::VALUE:
            return bind_value_expression(expr, bound_expressions);
        case ExprType::ARITHMETIC:
            return bind_arithmetic_expression(expr, bound_expressions);
        // ... 其他类型
        default:
            return RC::UNIMPLEMENTED;
    }
}
```

这是**策略模式**的典型应用：根据表达式类型选择不同的绑定策略。

## 4. 具体绑定方法详解

### 4.1 bind_unbound_field_expression() - 字段绑定
```cpp
RC bind_unbound_field_expression(unique_ptr<Expression> &unbound_field_expr, 
                                 vector<unique_ptr<Expression>> &bound_expressions)
{
    auto *unbound_expr = static_cast<UnboundFieldExpr*>(unbound_field_expr.get());
    
    const char *table_name = unbound_expr->table_name();
    const char *field_name = unbound_expr->field_name();
    
    // 1. 查找表
    Table *table = context_.find_table(table_name);
    if (table == nullptr) {
        LOG_WARN("No such table: %s", table_name);
        return RC::SCHEMA_TABLE_NOT_EXIST;
    }
    
    // 2. 查找字段
    const FieldMeta *field_meta = table->table_meta().field(field_name);
    if (field_meta == nullptr) {
        LOG_WARN("No such field: %s.%s", table->name(), field_name);
        return RC::SCHEMA_FIELD_NOT_EXIST;
    }
    
    // 3. 创建绑定后的字段表达式
    auto bound_expr = make_unique<FieldExpr>(table, field_meta);
    bound_expr->set_name(unbound_field_expr->name());  // 保持原有名字
    
    // 4. 替换原表达式
    unbound_field_expr = std::move(bound_expr);
    bound_expressions.push_back(unbound_field_expr->copy());
    
    return RC::SUCCESS;
}
```

**绑定过程的关键步骤：**
1. **类型转换：** `static_cast<UnboundFieldExpr*>` 安全转换
2. **表查找：** 在上下文中查找对应的表
3. **字段查找：** 在表元数据中查找字段
4. **对象创建：** 创建绑定后的FieldExpr
5. **表达式替换：** 用新对象替换原对象

### 4.2 bind_star_expression() - 星号展开
```cpp
RC bind_star_expression(unique_ptr<Expression> &star_expr, 
                       vector<unique_ptr<Expression>> &bound_expressions)
{
    auto *star = static_cast<StarExpr*>(star_expr.get());
    const char *table_name = star->table_name();
    
    if (table_name != nullptr && strlen(table_name) > 0) {
        // 指定表的星号：students.*
        Table *table = context_.find_table(table_name);
        if (table == nullptr) {
            return RC::SCHEMA_TABLE_NOT_EXIST;
        }
        
        // 展开该表的所有字段
        for (int i = 0; i < table->table_meta().field_num(); i++) {
            const FieldMeta *field_meta = table->table_meta().field(i);
            if (field_meta->visible()) {  // 只包含可见字段
                auto field_expr = make_unique<FieldExpr>(table, field_meta);
                bound_expressions.push_back(std::move(field_expr));
            }
        }
    } else {
        // 全局星号：*
        for (Table *table : context_.query_tables()) {
            for (int i = 0; i < table->table_meta().field_num(); i++) {
                const FieldMeta *field_meta = table->table_meta().field(i);
                if (field_meta->visible()) {
                    auto field_expr = make_unique<FieldExpr>(table, field_meta);
                    bound_expressions.push_back(std::move(field_expr));
                }
            }
        }
    }
    
    return RC::SUCCESS;
}
```

**星号展开示例：**
```sql
-- SELECT * FROM students
-- 展开为：SELECT id, name, age, grade FROM students

-- SELECT students.*, courses.title FROM students, courses  
-- 展开为：SELECT students.id, students.name, students.age, students.grade, courses.title FROM students, courses
```

### 4.3 bind_arithmetic_expression() - 递归绑定
```cpp
RC bind_arithmetic_expression(unique_ptr<Expression> &arithmetic_expr, 
                             vector<unique_ptr<Expression>> &bound_expressions)
{
    auto *arith = static_cast<ArithmeticExpr*>(arithmetic_expr.get());
    
    // 递归绑定左操作数
    vector<unique_ptr<Expression>> left_bound_exprs;
    RC rc = bind_expression(arith->left(), left_bound_exprs);
    if (rc != RC::SUCCESS) return rc;
    
    // 递归绑定右操作数（如果存在）
    if (arith->right()) {
        vector<unique_ptr<Expression>> right_bound_exprs;
        rc = bind_expression(arith->right(), right_bound_exprs);
        if (rc != RC::SUCCESS) return rc;
    }
    
    // 算术表达式本身已经绑定完成
    bound_expressions.push_back(arithmetic_expr->copy());
    return RC::SUCCESS;
}
```

**递归绑定的威力：**
```cpp
// 表达式：(students.age + 1) * courses.credit
//    *
//   / \
//  +   courses.credit (UnboundFieldExpr)
// / \
//students.age  1
//(UnboundFieldExpr) (ValueExpr)

// 绑定过程：
// 1. bind_arithmetic_expression() 处理乘法
// 2. 递归调用 bind_arithmetic_expression() 处理加法
// 3. 递归调用 bind_unbound_field_expression() 处理 students.age
// 4. 递归调用 bind_value_expression() 处理 1（直接返回）
// 5. 递归调用 bind_unbound_field_expression() 处理 courses.credit
```

## 5. 错误处理和调试

### 5.1 常见绑定错误
```cpp
// 1. 表不存在
// SQL: SELECT name FROM nonexistent_table
// 错误：RC::SCHEMA_TABLE_NOT_EXIST

// 2. 字段不存在  
// SQL: SELECT nonexistent_field FROM students
// 错误：RC::SCHEMA_FIELD_NOT_EXIST

// 3. 字段歧义（多表中有同名字段但未指定表名）
// SQL: SELECT id FROM students, courses  -- 两个表都有id字段
// 错误：RC::SCHEMA_FIELD_AMBIGUOUS

// 4. 类型不兼容
// SQL: SELECT name + age FROM students  -- 字符串不能与数字相加
// 错误：RC::INVALID_ARGUMENT
```

### 5.2 调试技巧
```cpp
// 在绑定过程中添加日志
RC bind_unbound_field_expression(...) {
    LOG_DEBUG("Binding field: %s.%s", table_name, field_name);
    
    Table *table = context_.find_table(table_name);
    if (table == nullptr) {
        LOG_ERROR("Table not found: %s", table_name);
        return RC::SCHEMA_TABLE_NOT_EXIST;
    }
    
    LOG_DEBUG("Found table: %s", table->name());
    // ...
}
```

## 6. 绑定器的使用场景

### 6.1 在SQL执行流程中的位置
```cpp
// SQL执行流程：
// 1. 词法分析 (Lexer)
// 2. 语法分析 (Parser) -> 产生 ParsedSqlNode
// 3. 语义分析 (Resolver) -> 使用 ExpressionBinder
// 4. 查询优化 (Optimizer)  
// 5. 执行计划生成
// 6. 执行

// 在Resolver阶段使用ExpressionBinder：
RC resolve_select_stmt(ParsedSqlNode *sql_node, SelectStmt *&stmt) {
    // 创建绑定上下文
    BinderContext context;
    for (auto &table_name : sql_node->selection.relations) {
        Table *table = db->find_table(table_name.c_str());
        context.add_table(table);
    }
    
    // 创建绑定器
    ExpressionBinder binder(context);
    
    // 绑定SELECT列表
    vector<unique_ptr<Expression>> select_exprs;
    for (auto &expr : sql_node->selection.expressions) {
        vector<unique_ptr<Expression>> bound_exprs;
        RC rc = binder.bind_expression(expr, bound_exprs);
        if (rc != RC::SUCCESS) return rc;
        
        select_exprs.insert(select_exprs.end(), 
                           make_move_iterator(bound_exprs.begin()),
                           make_move_iterator(bound_exprs.end()));
    }
    
    // 创建Statement对象
    stmt = new SelectStmt(std::move(select_exprs), ...);
    return RC::SUCCESS;
}
```

ExpressionBinder是连接SQL文本和执行对象的关键桥梁，它确保了类型安全和语义正确性！
