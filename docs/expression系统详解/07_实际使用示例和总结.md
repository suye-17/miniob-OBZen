# 实际使用示例和系统总结

## 1. 完整的SQL执行示例

### 1.1 示例SQL语句
```sql
SELECT name, age + 1 AS next_age, salary * 1.1 
FROM employees 
WHERE age > 25 AND department = 'IT'
ORDER BY salary DESC;
```

### 1.2 表达式解析过程

#### 步骤1：词法分析和语法分析
```cpp
// 解析器产生的未绑定表达式树
vector<unique_ptr<Expression>> select_expressions = {
    // name
    make_unique<UnboundFieldExpr>("", "name"),
    
    // age + 1 AS next_age
    make_unique<ArithmeticExpr>(ArithmeticExpr::Type::ADD,
        make_unique<UnboundFieldExpr>("", "age"),
        make_unique<ValueExpr>(Value(1))
    ),
    
    // salary * 1.1
    make_unique<ArithmeticExpr>(ArithmeticExpr::Type::MUL,
        make_unique<UnboundFieldExpr>("", "salary"),
        make_unique<ValueExpr>(Value(1.1f))
    )
};

// WHERE条件：age > 25 AND department = 'IT'
vector<unique_ptr<Expression>> where_conditions = {
    make_unique<ComparisonExpr>(GREAT_THAN,
        make_unique<UnboundFieldExpr>("", "age"),
        make_unique<ValueExpr>(Value(25))
    ),
    make_unique<ComparisonExpr>(EQUAL_TO,
        make_unique<UnboundFieldExpr>("", "department"),
        make_unique<ValueExpr>(Value("IT"))
    )
};

auto where_expr = make_unique<ConjunctionExpr>(
    ConjunctionExpr::Type::AND, 
    where_conditions
);
```

#### 步骤2：表达式绑定
```cpp
// 创建绑定上下文
BinderContext context;
Table* employees_table = db->find_table("employees");
context.add_table(employees_table);

// 创建绑定器
ExpressionBinder binder(context);

// 绑定SELECT表达式
vector<unique_ptr<Expression>> bound_select_exprs;
for (auto& expr : select_expressions) {
    vector<unique_ptr<Expression>> bound_exprs;
    RC rc = binder.bind_expression(expr, bound_exprs);
    if (rc != RC::SUCCESS) {
        LOG_ERROR("Failed to bind expression: %s", strrc(rc));
        return rc;
    }
    bound_select_exprs.insert(bound_select_exprs.end(),
                             make_move_iterator(bound_exprs.begin()),
                             make_move_iterator(bound_exprs.end()));
}

// 绑定WHERE表达式
vector<unique_ptr<Expression>> bound_where_exprs;
RC rc = binder.bind_expression(where_expr, bound_where_exprs);
```

#### 步骤3：绑定后的表达式树
```cpp
// 绑定后的SELECT表达式
vector<unique_ptr<Expression>> bound_select_exprs = {
    // name -> FieldExpr
    make_unique<FieldExpr>(employees_table, name_field_meta),
    
    // age + 1 -> ArithmeticExpr with bound children
    make_unique<ArithmeticExpr>(ArithmeticExpr::Type::ADD,
        make_unique<FieldExpr>(employees_table, age_field_meta),
        make_unique<ValueExpr>(Value(1))
    ),
    
    // salary * 1.1 -> ArithmeticExpr with bound children
    make_unique<ArithmeticExpr>(ArithmeticExpr::Type::MUL,
        make_unique<FieldExpr>(employees_table, salary_field_meta),
        make_unique<ValueExpr>(Value(1.1f))
    )
};

// 绑定后的WHERE表达式
auto bound_where_expr = make_unique<ConjunctionExpr>(
    ConjunctionExpr::Type::AND,
    vector<unique_ptr<Expression>>{
        make_unique<ComparisonExpr>(GREAT_THAN,
            make_unique<FieldExpr>(employees_table, age_field_meta),
            make_unique<ValueExpr>(Value(25))
        ),
        make_unique<ComparisonExpr>(EQUAL_TO,
            make_unique<FieldExpr>(employees_table, department_field_meta),
            make_unique<ValueExpr>(Value("IT"))
        )
    }
);
```

### 1.3 表达式执行过程

#### 逐行执行模式
```cpp
// 假设有一行员工数据
RowTuple employee_tuple;
employee_tuple.add_cell(TupleCell("张三"));     // name
employee_tuple.add_cell(TupleCell(28));        // age  
employee_tuple.add_cell(TupleCell(8000.0f));   // salary
employee_tuple.add_cell(TupleCell("IT"));      // department

// 1. 检查WHERE条件
Value where_result;
RC rc = bound_where_expr->get_value(employee_tuple, where_result);
if (rc == RC::SUCCESS && where_result.get_boolean()) {
    // 条件满足，计算SELECT表达式
    
    // name
    Value name_value;
    bound_select_exprs[0]->get_value(employee_tuple, name_value);
    // name_value = "张三"
    
    // age + 1
    Value next_age_value;
    bound_select_exprs[1]->get_value(employee_tuple, next_age_value);
    // next_age_value = 29 (28 + 1)
    
    // salary * 1.1
    Value new_salary_value;
    bound_select_exprs[2]->get_value(employee_tuple, new_salary_value);
    // new_salary_value = 8800.0 (8000.0 * 1.1)
    
    // 输出结果行
    cout << name_value.to_string() << ", " 
         << next_age_value.to_string() << ", "
         << new_salary_value.to_string() << endl;
    // 输出：张三, 29, 8800
}
```

#### 向量化执行模式
```cpp
// 假设有1000行员工数据的Chunk
Chunk employee_chunk;
// ... 填充数据 ...

// 1. 向量化WHERE过滤
vector<uint8_t> select_vector;
RC rc = bound_where_expr->eval(employee_chunk, select_vector);
// select_vector[i] = 1 表示第i行满足条件

// 2. 向量化SELECT计算
vector<Column> result_columns;

for (auto& expr : bound_select_exprs) {
    Column result_column;
    rc = expr->get_column(employee_chunk, result_column);
    result_columns.push_back(std::move(result_column));
}

// 3. 应用过滤条件
Chunk filtered_chunk;
for (size_t col_idx = 0; col_idx < result_columns.size(); col_idx++) {
    Column filtered_column;
    for (size_t row_idx = 0; row_idx < select_vector.size(); row_idx++) {
        if (select_vector[row_idx]) {
            filtered_column.append(result_columns[col_idx].get_value(row_idx));
        }
    }
    filtered_chunk.add_column(std::move(filtered_column));
}

// filtered_chunk现在包含所有满足条件的结果行
```

## 2. 复杂聚合查询示例

### 2.1 SQL语句
```sql
SELECT department, COUNT(*), AVG(salary), MAX(age)
FROM employees 
WHERE salary > 5000
GROUP BY department
HAVING AVG(salary) > 8000
ORDER BY AVG(salary) DESC;
```

### 2.2 表达式分析
```cpp
// SELECT列表表达式
vector<unique_ptr<Expression>> select_exprs = {
    // department - 分组字段
    make_unique<FieldExpr>(employees_table, dept_field_meta),
    
    // COUNT(*) - 计数聚合
    make_unique<AggregateExpr>(AggregateExpr::Type::COUNT,
        make_unique<StarExpr>()
    ),
    
    // AVG(salary) - 平均值聚合
    make_unique<AggregateExpr>(AggregateExpr::Type::AVG,
        make_unique<FieldExpr>(employees_table, salary_field_meta)
    ),
    
    // MAX(age) - 最大值聚合
    make_unique<AggregateExpr>(AggregateExpr::Type::MAX,
        make_unique<FieldExpr>(employees_table, age_field_meta)
    )
};

// WHERE条件：salary > 5000
auto where_expr = make_unique<ComparisonExpr>(GREAT_THAN,
    make_unique<FieldExpr>(employees_table, salary_field_meta),
    make_unique<ValueExpr>(Value(5000.0f))
);

// HAVING条件：AVG(salary) > 8000
auto having_expr = make_unique<ComparisonExpr>(GREAT_THAN,
    make_unique<AggregateExpr>(AggregateExpr::Type::AVG,
        make_unique<FieldExpr>(employees_table, salary_field_meta)
    ),
    make_unique<ValueExpr>(Value(8000.0f))
);
```

### 2.3 聚合执行流程
```cpp
// 1. 数据分组（按department）
map<string, vector<RowTuple>> groups;
for (auto& tuple : all_tuples) {
    // 检查WHERE条件
    Value where_result;
    where_expr->get_value(tuple, where_result);
    if (!where_result.get_boolean()) continue;
    
    // 获取分组键
    Value dept_value;
    select_exprs[0]->get_value(tuple, dept_value);
    string dept = dept_value.to_string();
    
    groups[dept].push_back(tuple);
}

// 2. 对每个分组执行聚合计算
vector<RowTuple> result_tuples;
for (auto& [dept, group_tuples] : groups) {
    // 创建聚合器
    vector<unique_ptr<Aggregator>> aggregators;
    for (size_t i = 1; i < select_exprs.size(); i++) {  // 跳过分组字段
        if (select_exprs[i]->type() == ExprType::AGGREGATION) {
            auto* agg_expr = static_cast<AggregateExpr*>(select_exprs[i].get());
            aggregators.push_back(agg_expr->create_aggregator());
        }
    }
    
    // 累积每行数据到聚合器
    for (auto& tuple : group_tuples) {
        for (size_t i = 0; i < aggregators.size(); i++) {
            Value child_value;
            auto* agg_expr = static_cast<AggregateExpr*>(select_exprs[i+1].get());
            agg_expr->child()->get_value(tuple, child_value);
            aggregators[i]->accumulate(child_value);
        }
    }
    
    // 计算聚合结果
    RowTuple result_tuple;
    result_tuple.add_cell(TupleCell(dept));  // 分组字段
    
    for (auto& aggregator : aggregators) {
        Value agg_result;
        aggregator->evaluate(agg_result);
        result_tuple.add_cell(TupleCell(agg_result));
    }
    
    // 检查HAVING条件
    Value having_result;
    having_expr->get_value(result_tuple, having_result);
    if (having_result.get_boolean()) {
        result_tuples.push_back(result_tuple);
    }
}

// 3. 按AVG(salary)排序
sort(result_tuples.begin(), result_tuples.end(), [&](const RowTuple& a, const RowTuple& b) {
    // 比较AVG(salary)列（第3列，索引为2）
    return a.cell_at(2).get_value().get_float() > b.cell_at(2).get_value().get_float();
});
```

## 3. 表达式系统的设计优势

### 3.1 统一的接口设计
```cpp
// 所有表达式都实现相同的接口
class Expression {
public:
    virtual RC get_value(const Tuple& tuple, Value& value) const = 0;
    virtual AttrType value_type() const = 0;
    virtual ExprType type() const = 0;
    // ...
};

// 使用者不需要关心具体类型
void process_expression(const Expression& expr, const Tuple& tuple) {
    Value result;
    RC rc = expr.get_value(tuple, result);  // 多态调用
    if (rc == RC::SUCCESS) {
        cout << "Result: " << result.to_string() << endl;
    }
}

// 可以处理任何类型的表达式
process_expression(ValueExpr(42), tuple);           // 常量
process_expression(FieldExpr(table, field), tuple); // 字段
process_expression(ArithmeticExpr(...), tuple);     // 算术
```

### 3.2 递归组合的威力
```cpp
// 复杂表达式可以由简单表达式组合而成
// (age + bonus) * tax_rate - base_deduction

auto age_expr = make_unique<FieldExpr>(table, age_field);
auto bonus_expr = make_unique<FieldExpr>(table, bonus_field);
auto tax_rate_expr = make_unique<ValueExpr>(Value(0.3f));
auto base_deduction_expr = make_unique<ValueExpr>(Value(1000.0f));

auto age_plus_bonus = make_unique<ArithmeticExpr>(
    ArithmeticExpr::Type::ADD, 
    std::move(age_expr), 
    std::move(bonus_expr)
);

auto taxable_income = make_unique<ArithmeticExpr>(
    ArithmeticExpr::Type::MUL,
    std::move(age_plus_bonus),
    std::move(tax_rate_expr)
);

auto final_tax = make_unique<ArithmeticExpr>(
    ArithmeticExpr::Type::SUB,
    std::move(taxable_income),
    std::move(base_deduction_expr)
);

// 一次调用计算整个复杂表达式
Value tax_amount;
final_tax->get_value(employee_tuple, tax_amount);
```

### 3.3 类型安全和错误处理
```cpp
// 编译时类型检查
ArithmeticExpr expr(ArithmeticExpr::Type::ADD,
    make_unique<FieldExpr>(table, name_field),    // 字符串类型
    make_unique<ValueExpr>(Value(10))             // 整数类型
);

// 运行时会返回错误
Value result;
RC rc = expr.get_value(tuple, result);
// rc == RC::INVALID_ARGUMENT，因为字符串不能与整数相加

// 通过返回码进行错误处理
if (rc != RC::SUCCESS) {
    LOG_ERROR("Expression evaluation failed: %s", strrc(rc));
    // 适当的错误处理...
}
```

### 3.4 性能优化支持
```cpp
// 1. 常量折叠
auto const_expr = make_unique<ArithmeticExpr>(
    ArithmeticExpr::Type::ADD,
    make_unique<ValueExpr>(Value(1)),
    make_unique<ValueExpr>(Value(2))
);

Value result;
RC rc = const_expr->try_get_value(result);  // 编译时计算：result = 3

// 2. 向量化执行
Chunk chunk;  // 1000行数据
Column result_column;
expression->get_column(chunk, result_column);  // 批量计算1000个结果

// 3. 位置缓存
// 如果表达式已经在下层算子中计算过，直接从chunk中获取
if (expr->pos() >= 0) {
    column.reference(chunk.column(expr->pos()));  // 零拷贝获取结果
}
```

## 4. 学习建议和扩展方向

### 4.1 深入学习建议
1. **理解多态机制：** 重点掌握虚函数的工作原理
2. **掌握智能指针：** 理解unique_ptr的移动语义
3. **学习设计模式：** 策略模式、组合模式、访问者模式
4. **研究向量化计算：** 理解SIMD和批量处理的优势
5. **分析错误处理：** 学习如何设计健壮的错误处理机制

### 4.2 可能的扩展方向
```cpp
// 1. 支持更多表达式类型
class FunctionExpr : public Expression {
    // 支持 UPPER(name), LENGTH(description) 等函数
};

class CaseExpr : public Expression {
    // 支持 CASE WHEN age > 18 THEN 'adult' ELSE 'minor' END
};

// 2. 支持子查询表达式
class SubqueryExpr : public Expression {
    // 支持 age > (SELECT AVG(age) FROM employees)
};

// 3. 支持窗口函数
class WindowFunctionExpr : public Expression {
    // 支持 ROW_NUMBER() OVER (ORDER BY salary DESC)
};
```

### 4.3 性能优化方向
```cpp
// 1. 表达式编译
class CompiledExpression {
    // 将表达式编译为机器码或字节码
    void* compiled_code_;
public:
    RC execute(const Tuple& tuple, Value& result);
};

// 2. 表达式缓存
class ExpressionCache {
    // 缓存表达式的计算结果
    unordered_map<string, Value> cache_;
};

// 3. 并行计算
class ParallelExpressionEvaluator {
    // 利用多核CPU并行计算表达式
    thread_pool pool_;
};
```

## 5. 总结

MiniOB的表达式系统是一个设计精良、功能完整的组件：

1. **统一抽象：** Expression基类提供统一接口
2. **类型丰富：** 支持常量、字段、算术、比较、聚合等多种表达式
3. **递归组合：** 复杂表达式由简单表达式组合而成
4. **类型安全：** 编译时和运行时双重类型检查
5. **性能优化：** 支持向量化执行和多种优化技术
6. **错误处理：** 完善的错误检测和处理机制

这个系统为数据库的查询处理提供了强大而灵活的基础设施，是学习数据库内核开发的绝佳案例！
