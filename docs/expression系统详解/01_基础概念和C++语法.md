# MiniOB表达式系统详解 - 基础概念和C++语法

## 1. 什么是表达式（Expression）？

### 1.1 日常生活中的表达式
想象你在计算器上按键：
- `1 + 2` - 这是一个加法表达式
- `3 * (4 + 5)` - 这是一个包含括号的复杂表达式
- `age > 18` - 这是一个比较表达式

在数据库中，表达式就是能够计算出值的任何东西！

### 1.2 数据库中的表达式类型
```sql
-- 常量表达式
SELECT 1, 'hello', 3.14;

-- 字段表达式
SELECT name, age FROM students;

-- 算术表达式
SELECT age + 1, salary * 1.1 FROM employees;

-- 比较表达式
SELECT * FROM students WHERE age > 18;

-- 聚合表达式
SELECT COUNT(*), SUM(salary) FROM employees;
```

## 2. C++基础语法回顾

### 2.1 类和继承（Class & Inheritance）
```cpp
// 基类（父类）
class Animal {
public:
    virtual void make_sound() = 0;  // 纯虚函数，必须被子类实现
    virtual ~Animal() = default;    // 虚析构函数
};

// 派生类（子类）
class Dog : public Animal {
public:
    void make_sound() override {    // override关键字确保正确重写
        cout << "Woof!" << endl;
    }
};
```

**关键概念：**
- `virtual` - 允许子类重写这个函数
- `= 0` - 纯虚函数，这个类不能直接创建对象
- `override` - 明确告诉编译器这是重写父类函数
- `public` - 继承方式，子类可以访问父类的public成员

### 2.2 智能指针（Smart Pointers）
```cpp
#include <memory>

// 旧式写法（容易内存泄漏）
Expression* expr = new ValueExpr(10);
delete expr;  // 忘记delete就内存泄漏了！

// 现代写法（自动管理内存）
std::unique_ptr<Expression> expr = std::make_unique<ValueExpr>(10);
// 不需要手动delete，离开作用域自动释放
```

**unique_ptr特点：**
- 独占所有权，不能复制，只能移动
- 自动释放内存，不会内存泄漏
- `std::move()` - 转移所有权

### 2.3 枚举类（Enum Class）
```cpp
// 旧式枚举
enum Color { RED, GREEN, BLUE };  // 问题：RED可能与其他地方冲突

// 现代强类型枚举
enum class ExprType {
    VALUE,      // ExprType::VALUE
    FIELD,      // ExprType::FIELD  
    ARITHMETIC  // ExprType::ARITHMETIC
};

// 使用
ExprType type = ExprType::VALUE;
if (type == ExprType::VALUE) {
    // 处理常量表达式
}
```

### 2.4 虚函数和多态
```cpp
class Expression {
public:
    // 纯虚函数 - 子类必须实现
    virtual RC get_value(const Tuple& tuple, Value& value) const = 0;
    
    // 虚函数 - 子类可以选择重写
    virtual AttrType value_type() const { return AttrType::UNDEFINED; }
};

class ValueExpr : public Expression {
public:
    // 重写纯虚函数
    RC get_value(const Tuple& tuple, Value& value) const override {
        value = value_;  // 直接返回存储的值
        return RC::SUCCESS;
    }
    
    // 重写虚函数
    AttrType value_type() const override {
        return value_.attr_type();
    }
};
```

## 3. 设计模式：策略模式和访问者模式

### 3.1 策略模式在表达式中的应用
```cpp
// 不同类型的表达式就是不同的"策略"
std::unique_ptr<Expression> expr;

if (需要常量) {
    expr = std::make_unique<ValueExpr>(42);
} else if (需要字段) {
    expr = std::make_unique<FieldExpr>(table, field);
} else if (需要算术运算) {
    expr = std::make_unique<ArithmeticExpr>(ADD, left, right);
}

// 统一接口调用，具体行为由实际类型决定
Value result;
expr->get_value(tuple, result);  // 多态调用
```

### 3.2 组合模式
```cpp
// 复杂表达式由简单表达式组合而成
// 例如：(a + b) * c

auto a = std::make_unique<FieldExpr>("a");
auto b = std::make_unique<FieldExpr>("b");
auto c = std::make_unique<FieldExpr>("c");

// a + b
auto add_expr = std::make_unique<ArithmeticExpr>(ADD, std::move(a), std::move(b));

// (a + b) * c
auto mul_expr = std::make_unique<ArithmeticExpr>(MUL, std::move(add_expr), std::move(c));
```

## 4. MiniOB表达式系统整体架构

```
Expression (抽象基类)
├── StarExpr (SELECT * 的星号)
├── ValueExpr (常量值：1, 'hello', 3.14)
├── FieldExpr (字段引用：table.column)
├── UnboundFieldExpr (解析时的临时状态)
├── CastExpr (类型转换：CAST(age AS FLOAT))
├── ComparisonExpr (比较：age > 18)
├── ConjunctionExpr (逻辑连接：expr1 AND expr2)
├── ArithmeticExpr (算术运算：a + b * c)
├── AggregateExpr (聚合函数：COUNT, SUM, AVG)
└── UnboundAggregateExpr (解析时的临时状态)
```

## 5. 核心接口说明

### 5.1 Expression基类的核心方法
```cpp
class Expression {
public:
    // 获取表达式类型（用于类型判断和转换）
    virtual ExprType type() const = 0;
    
    // 获取表达式计算结果的数据类型
    virtual AttrType value_type() const = 0;
    
    // 根据tuple计算表达式的值（核心方法）
    virtual RC get_value(const Tuple& tuple, Value& value) const = 0;
    
    // 复制表达式（深拷贝）
    virtual std::unique_ptr<Expression> copy() const = 0;
    
    // 比较两个表达式是否相等
    virtual bool equal(const Expression& other) const { return false; }
    
    // 表达式的名字（用于显示）
    virtual const char* name() const { return name_.c_str(); }
};
```

### 5.2 关键概念解释

**Tuple（元组）：** 
- 就像数据库表中的一行数据
- 包含多个字段的值
- 例如：{"张三", 20, "男"} 就是一个tuple

**Value（值）：**
- 存储具体的数据值和类型信息
- 例如：整数42、字符串"hello"、浮点数3.14

**RC（返回码）：**
- Return Code的缩写
- 表示操作是否成功：RC::SUCCESS, RC::INVALID_ARGUMENT等

## 6. 下一步学习计划

1. **表达式基类详解** - expression.h/cpp
2. **具体表达式实现** - 各种Expression子类
3. **表达式解析** - expression_binder
4. **表达式计算** - get_value方法实现
5. **优化器集成** - expression_rewriter

让我们从最简单的ValueExpr开始，逐步深入！
