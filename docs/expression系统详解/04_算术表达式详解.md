# 算术表达式详解 - 复杂表达式的典型代表

## 1. ArithmeticExpr类结构分析

### 1.1 类定义概览
```cpp
class ArithmeticExpr : public Expression
{
public:
  enum class Type  // 算术运算类型
  {
    ADD,      // 加法: a + b
    SUB,      // 减法: a - b  
    MUL,      // 乘法: a * b
    DIV,      // 除法: a / b
    NEGATIVE, // 负号: -a (一元运算)
  };

public:
  // 构造函数：支持两种参数类型
  ArithmeticExpr(Type type, Expression *left, Expression *right);           // 原始指针版本
  ArithmeticExpr(Type type, unique_ptr<Expression> left, unique_ptr<Expression> right);  // 智能指针版本
  
  virtual ~ArithmeticExpr() = default;

  // 基类接口实现
  unique_ptr<Expression> copy() const override;
  bool equal(const Expression &other) const override;
  ExprType type() const override { return ExprType::ARITHMETIC; }
  AttrType value_type() const override;    // 根据操作数类型推导结果类型
  int value_length() const override;
  RC get_value(const Tuple &tuple, Value &value) const override;
  RC get_column(Chunk &chunk, Column &column) override;
  RC try_get_value(Value &value) const override;

  // 算术表达式特有方法
  Type arithmetic_type() const { return arithmetic_type_; }
  unique_ptr<Expression> &left() { return left_; }
  unique_ptr<Expression> &right() { return right_; }

private:
  // 计算方法
  RC calc_value(const Value &left_value, const Value &right_value, Value &value) const;
  RC calc_column(const Column &left_column, const Column &right_column, Column &column) const;
  
  // 向量化计算模板（高性能）
  template <bool LEFT_CONSTANT, bool RIGHT_CONSTANT>
  RC execute_calc(const Column &left, const Column &right, Column &result, Type type, AttrType attr_type) const;

private:
  Type arithmetic_type_;              // 运算类型
  unique_ptr<Expression> left_;       // 左操作数
  unique_ptr<Expression> right_;      // 右操作数（负号运算时为nullptr）
};
```

### 1.2 C++语法学习点

#### 嵌套枚举类
```cpp
enum class Type { ADD, SUB, MUL, DIV, NEGATIVE };
```

**为什么要嵌套在类内部？**
```cpp
// 如果定义在类外部
enum class ArithmeticType { ADD, SUB, MUL, DIV, NEGATIVE };

// 使用时：
ArithmeticType op = ArithmeticType::ADD;  // 比较冗长

// 嵌套在类内部后：
ArithmeticExpr::Type op = ArithmeticExpr::Type::ADD;  // 语义更清晰
// 或者在类内部直接用：Type::ADD
```

#### 构造函数重载
```cpp
// 版本1：接受原始指针（为了兼容旧代码）
ArithmeticExpr(Type type, Expression *left, Expression *right);

// 版本2：接受智能指针（推荐使用）
ArithmeticExpr(Type type, unique_ptr<Expression> left, unique_ptr<Expression> right);

// 使用示例：
auto left = make_unique<ValueExpr>(10);
auto right = make_unique<ValueExpr>(20);

// 方式1：移动语义
ArithmeticExpr expr1(Type::ADD, std::move(left), std::move(right));

// 方式2：直接构造
ArithmeticExpr expr2(Type::ADD, 
    make_unique<ValueExpr>(10), 
    make_unique<ValueExpr>(20)
);
```

## 2. 核心方法实现分析

### 2.1 copy()方法 - 深拷贝的艺术
```cpp
unique_ptr<Expression> copy() const override
{
  if (right_) {  // 二元运算
    return make_unique<ArithmeticExpr>(arithmetic_type_, left_->copy(), right_->copy());
  } else {       // 一元运算（负号）
    return make_unique<ArithmeticExpr>(arithmetic_type_, left_->copy(), nullptr);
  }
}
```

**关键点：**
- 递归复制子表达式（`left_->copy()`, `right_->copy()`）
- 处理一元运算的特殊情况（`right_` 为 `nullptr`）
- 返回完全独立的新对象

**深拷贝 vs 浅拷贝：**
```cpp
// 浅拷贝（错误示例）
unique_ptr<Expression> bad_copy() const {
    return make_unique<ArithmeticExpr>(arithmetic_type_, left_.get(), right_.get());
    // 问题：新对象和原对象共享子表达式，修改一个会影响另一个！
}

// 深拷贝（正确做法）
unique_ptr<Expression> good_copy() const {
    return make_unique<ArithmeticExpr>(arithmetic_type_, left_->copy(), right_->copy());
    // 正确：完全独立的对象树
}
```

### 2.2 value_type() - 类型推导
```cpp
AttrType value_type() const override;  // 在.cpp文件中实现
```

**类型推导规则（从expression.cpp推测）：**
```cpp
AttrType ArithmeticExpr::value_type() const 
{
    AttrType left_type = left_->value_type();
    AttrType right_type = right_ ? right_->value_type() : left_type;
    
    // 类型提升规则
    if (left_type == AttrType::FLOATS || right_type == AttrType::FLOATS) {
        return AttrType::FLOATS;  // 有浮点数就返回浮点数
    }
    
    if (arithmetic_type_ == Type::DIV) {
        return AttrType::FLOATS;  // 除法总是返回浮点数
    }
    
    return AttrType::INTS;  // 默认整数
}
```

**使用示例：**
```cpp
// int + int = int
auto expr1 = ArithmeticExpr(Type::ADD, 
    make_unique<ValueExpr>(Value(10)),     // int
    make_unique<ValueExpr>(Value(20))      // int
);
// expr1.value_type() == AttrType::INTS

// int + float = float  
auto expr2 = ArithmeticExpr(Type::ADD,
    make_unique<ValueExpr>(Value(10)),     // int
    make_unique<ValueExpr>(Value(3.14f))   // float
);
// expr2.value_type() == AttrType::FLOATS

// int / int = float (除法特殊处理)
auto expr3 = ArithmeticExpr(Type::DIV,
    make_unique<ValueExpr>(Value(10)),     // int
    make_unique<ValueExpr>(Value(3))       // int
);
// expr3.value_type() == AttrType::FLOATS
```

### 2.3 get_value() - 递归计算
```cpp
RC get_value(const Tuple &tuple, Value &value) const override
{
    Value left_value;
    RC rc = left_->get_value(tuple, left_value);  // 递归计算左操作数
    if (rc != RC::SUCCESS) return rc;

    if (right_) {  // 二元运算
        Value right_value;
        rc = right_->get_value(tuple, right_value);  // 递归计算右操作数
        if (rc != RC::SUCCESS) return rc;
        
        return calc_value(left_value, right_value, value);  // 执行运算
    } else {  // 一元运算（负号）
        return calc_value(left_value, Value(), value);  // 右操作数为空
    }
}
```

**递归计算流程：**
```cpp
// 表达式树：(age + 1) * 2
//     *
//    / \
//   +   2
//  / \
// age 1

// 计算过程：
// 1. 计算左子树 (age + 1)
//    1.1 计算 age -> 从tuple获取，假设为20
//    1.2 计算 1 -> 常量，直接返回1
//    1.3 执行 20 + 1 = 21
// 2. 计算右子树 2 -> 常量，直接返回2
// 3. 执行 21 * 2 = 42
```

### 2.4 calc_value() - 实际运算逻辑
```cpp
RC calc_value(const Value &left_value, const Value &right_value, Value &value) const
{
    switch (arithmetic_type_) {
        case Type::ADD:
            return Value::add(left_value, right_value, value);
        case Type::SUB:
            return Value::subtract(left_value, right_value, value);
        case Type::MUL:
            return Value::multiply(left_value, right_value, value);
        case Type::DIV:
            return Value::divide(left_value, right_value, value);
        case Type::NEGATIVE:
            return Value::negative(left_value, value);
        default:
            return RC::INTERNAL;
    }
}
```

## 3. 向量化计算支持

### 3.1 get_column() - 批量处理
```cpp
RC get_column(Chunk &chunk, Column &column) override;
```

**向量化的优势：**
```cpp
// 传统方式：逐行计算（慢）
for (int i = 0; i < 1000; i++) {
    Value left, right, result;
    left_expr->get_value(tuples[i], left);
    right_expr->get_value(tuples[i], right);
    Value::add(left, right, result);
    results[i] = result;
}

// 向量化方式：批量计算（快）
Column left_column, right_column, result_column;
left_expr->get_column(chunk, left_column);   // 一次计算1000个左值
right_expr->get_column(chunk, right_column); // 一次计算1000个右值
Column::add(left_column, right_column, result_column);  // 向量化加法
```

### 3.2 模板函数 - 编译时优化
```cpp
template <bool LEFT_CONSTANT, bool RIGHT_CONSTANT>
RC execute_calc(const Column &left, const Column &right, Column &result, Type type, AttrType attr_type) const;
```

**模板特化的威力：**
```cpp
// 编译器会生成4个不同的函数版本：
// execute_calc<true, true>    - 两个操作数都是常量
// execute_calc<true, false>   - 左常量，右变量  
// execute_calc<false, true>   - 左变量，右常量
// execute_calc<false, false>  - 两个操作数都是变量

// 每个版本都有针对性优化，避免运行时判断
```

## 4. 表达式树的构建

### 4.1 复杂表达式示例
```cpp
// SQL: SELECT (age + 1) * salary - 100 FROM employees
// 对应的表达式树：
//        -
//       / \
//      *   100
//     / \
//    +   salary
//   / \
//  age 1

// C++构建代码：
auto age = make_unique<FieldExpr>(table, age_field);
auto one = make_unique<ValueExpr>(Value(1));
auto salary = make_unique<FieldExpr>(table, salary_field);
auto hundred = make_unique<ValueExpr>(Value(100));

auto age_plus_one = make_unique<ArithmeticExpr>(Type::ADD, move(age), move(one));
auto mul_salary = make_unique<ArithmeticExpr>(Type::MUL, move(age_plus_one), move(salary));
auto final_expr = make_unique<ArithmeticExpr>(Type::SUB, move(mul_salary), move(hundred));
```

### 4.2 一元运算处理
```cpp
// SQL: SELECT -age FROM employees
// 表达式树：
//   NEGATIVE
//      |
//     age

// C++构建：
auto age = make_unique<FieldExpr>(table, age_field);
auto neg_age = make_unique<ArithmeticExpr>(Type::NEGATIVE, move(age), nullptr);
//                                                                    ^^^^^^^
//                                                                    右操作数为空
```

## 5. 错误处理和边界情况

### 5.1 除零错误
```cpp
// Value::divide内部处理
RC Value::divide(const Value &left, const Value &right, Value &result) {
    if (right.get_int() == 0 || right.get_float() == 0.0f) {
        return RC::INVALID_ARGUMENT;  // 除零错误
    }
    // 正常除法计算...
}
```

### 5.2 类型不兼容
```cpp
// 字符串不能参与算术运算
Value str_val("hello");
Value int_val(42);
Value result;
RC rc = Value::add(str_val, int_val, result);  // 返回错误码
```

## 6. 性能优化技巧

### 6.1 常量折叠优化
```cpp
// SQL: SELECT age + (1 + 2) FROM employees
// 优化前的表达式树：
//     +
//    / \
//   age +
//      / \
//     1   2

// 优化后：
//     +
//    / \
//   age 3  (1+2在编译时计算)
```

### 6.2 短路求值（未来可能的优化）
```cpp
// 对于 0 * expr，可以直接返回0，不计算expr
if (left_value.get_int() == 0 && arithmetic_type_ == Type::MUL) {
    value = Value(0);
    return RC::SUCCESS;
}
```

算术表达式是表达式系统中最复杂的部分之一，它展示了递归设计、类型推导、向量化计算等多种高级技术。下一步我们来看比较表达式和聚合表达式！
