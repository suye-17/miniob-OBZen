# 比较表达式和聚合表达式详解

## 1. ComparisonExpr - 比较表达式

### 1.1 类结构分析
```cpp
class ComparisonExpr : public Expression
{
public:
  ComparisonExpr(CompOp comp, unique_ptr<Expression> left, unique_ptr<Expression> right);
  virtual ~ComparisonExpr();

  ExprType type() const override { return ExprType::COMPARISON; }
  RC       get_value(const Tuple &tuple, Value &value) const override;
  AttrType value_type() const override { return AttrType::BOOLEANS; }  // 比较结果总是布尔值
  CompOp   comp() const { return comp_; }

  unique_ptr<Expression> copy() const override
  {
    return make_unique<ComparisonExpr>(comp_, left_->copy(), right_->copy());
  }

  // 向量化比较 - 高性能批量处理
  RC eval(Chunk &chunk, vector<uint8_t> &select) override;

  unique_ptr<Expression> &left() { return left_; }
  unique_ptr<Expression> &right() { return right_; }

  RC try_get_value(Value &value) const override;
  RC compare_value(const Value &left, const Value &right, bool &value) const;

  // 向量化比较模板
  template <typename T>
  RC compare_column(const Column &left, const Column &right, vector<uint8_t> &result) const;

private:
  CompOp                 comp_;     // 比较操作符
  unique_ptr<Expression> left_;    // 左操作数
  unique_ptr<Expression> right_;   // 右操作数
};
```

### 1.2 CompOp枚举类型
```cpp
// 在其他头文件中定义
enum CompOp {
    EQUAL_TO,     // =
    LESS_EQUAL,   // <=
    NOT_EQUAL,    // !=
    LESS_THAN,    // <
    GREAT_EQUAL,  // >=
    GREAT_THAN,   // >
};
```

### 1.3 核心方法详解

#### get_value() - 逐行比较
```cpp
RC get_value(const Tuple &tuple, Value &value) const override
{
    Value left_value, right_value;
    
    // 计算左右操作数的值
    RC rc = left_->get_value(tuple, left_value);
    if (rc != RC::SUCCESS) return rc;
    
    rc = right_->get_value(tuple, right_value);
    if (rc != RC::SUCCESS) return rc;
    
    // 执行比较
    bool result;
    rc = compare_value(left_value, right_value, result);
    if (rc != RC::SUCCESS) return rc;
    
    value = Value(result);  // 将布尔结果包装为Value
    return RC::SUCCESS;
}
```

#### compare_value() - 具体比较逻辑
```cpp
RC compare_value(const Value &left, const Value &right, bool &result) const
{
    int cmp_result = left.compare(right);  // 调用Value的compare方法
    
    switch (comp_) {
        case EQUAL_TO:    result = (cmp_result == 0); break;
        case LESS_THAN:   result = (cmp_result < 0);  break;
        case GREAT_THAN:  result = (cmp_result > 0);  break;
        case LESS_EQUAL:  result = (cmp_result <= 0); break;
        case GREAT_EQUAL: result = (cmp_result >= 0); break;
        case NOT_EQUAL:   result = (cmp_result != 0); break;
        default: return RC::INTERNAL;
    }
    
    return RC::SUCCESS;
}
```

**Value::compare()方法的工作原理：**
```cpp
// Value类中的compare方法（简化版）
int Value::compare(const Value& other) const {
    // 类型不同时的处理
    if (attr_type_ != other.attr_type_) {
        // 进行类型转换后比较
        // 例如：int 10 vs float 10.0 -> 相等
    }
    
    switch (attr_type_) {
        case AttrType::INTS:
            return num_value_.int_value_ - other.num_value_.int_value_;
        case AttrType::FLOATS:
            float diff = num_value_.float_value_ - other.num_value_.float_value_;
            return diff > 0 ? 1 : (diff < 0 ? -1 : 0);
        case AttrType::CHARS:
            return strcmp(str_value_.c_str(), other.str_value_.c_str());
        // ... 其他类型
    }
}
```

### 1.4 向量化比较 - eval()方法
```cpp
RC eval(Chunk &chunk, vector<uint8_t> &select) override
{
    Column left_column, right_column;
    
    // 获取左右操作数的列数据
    RC rc = left_->get_column(chunk, left_column);
    if (rc != RC::SUCCESS) return rc;
    
    rc = right_->get_column(chunk, right_column);
    if (rc != RC::SUCCESS) return rc;
    
    // 向量化比较
    select.resize(chunk.rows());
    return compare_column<int>(left_column, right_column, select);
}
```

**select向量的含义：**
```cpp
// select[i] = 1 表示第i行满足条件
// select[i] = 0 表示第i行不满足条件

// 例如：WHERE age > 18
// 数据：[16, 20, 15, 25, 19]
// 结果：[0,  1,  0,  1,  1]
//       不满足,满足,不满足,满足,满足
```

### 1.5 使用示例
```cpp
// SQL: SELECT * FROM students WHERE age > 18
auto age_field = make_unique<FieldExpr>(table, age_field_meta);
auto eighteen = make_unique<ValueExpr>(Value(18));
auto condition = make_unique<ComparisonExpr>(GREAT_THAN, move(age_field), move(eighteen));

// 逐行使用
RowTuple tuple;  // 假设包含一个学生的数据
Value result;
condition->get_value(tuple, result);  // result是布尔值

// 向量化使用
Chunk chunk;     // 假设包含1000个学生的数据
vector<uint8_t> select;
condition->eval(chunk, select);  // select[i]表示第i个学生是否满足条件
```

## 2. ConjunctionExpr - 逻辑连接表达式

### 2.1 类结构分析
```cpp
class ConjunctionExpr : public Expression
{
public:
  enum class Type
  {
    AND,  // 逻辑与
    OR    // 逻辑或
  };

public:
  ConjunctionExpr(Type type, vector<unique_ptr<Expression>> &children);
  virtual ~ConjunctionExpr() = default;

  unique_ptr<Expression> copy() const override
  {
    vector<unique_ptr<Expression>> children;
    for (auto &child : children_) {
      children.emplace_back(child->copy());  // 深拷贝所有子表达式
    }
    return make_unique<ConjunctionExpr>(conjunction_type_, children);
  }

  ExprType type() const override { return ExprType::CONJUNCTION; }
  AttrType value_type() const override { return AttrType::BOOLEANS; }
  RC       get_value(const Tuple &tuple, Value &value) const override;

  Type conjunction_type() const { return conjunction_type_; }
  vector<unique_ptr<Expression>> &children() { return children_; }

private:
  Type                           conjunction_type_;  // AND 或 OR
  vector<unique_ptr<Expression>> children_;          // 子表达式列表
};
```

### 2.2 get_value()实现 - 短路求值
```cpp
RC get_value(const Tuple &tuple, Value &value) const override
{
    if (conjunction_type_ == Type::AND) {
        // AND：所有条件都为真才为真
        for (auto &child : children_) {
            Value child_value;
            RC rc = child->get_value(tuple, child_value);
            if (rc != RC::SUCCESS) return rc;
            
            if (!child_value.get_boolean()) {  // 发现false就短路返回
                value = Value(false);
                return RC::SUCCESS;
            }
        }
        value = Value(true);  // 所有都为true
        
    } else {  // OR
        // OR：任一条件为真就为真
        for (auto &child : children_) {
            Value child_value;
            RC rc = child->get_value(tuple, child_value);
            if (rc != RC::SUCCESS) return rc;
            
            if (child_value.get_boolean()) {   // 发现true就短路返回
                value = Value(true);
                return RC::SUCCESS;
            }
        }
        value = Value(false);  // 所有都为false
    }
    
    return RC::SUCCESS;
}
```

**短路求值的优势：**
```cpp
// SQL: WHERE expensive_function() AND age > 18
// 如果age <= 18，expensive_function()根本不会被调用！

// SQL: WHERE age > 18 OR expensive_function()  
// 如果age > 18，expensive_function()根本不会被调用！
```

### 2.3 使用示例
```cpp
// SQL: WHERE age > 18 AND salary > 5000
vector<unique_ptr<Expression>> conditions;

// age > 18
conditions.push_back(make_unique<ComparisonExpr>(
    GREAT_THAN,
    make_unique<FieldExpr>(table, age_field),
    make_unique<ValueExpr>(Value(18))
));

// salary > 5000  
conditions.push_back(make_unique<ComparisonExpr>(
    GREAT_THAN,
    make_unique<FieldExpr>(table, salary_field),
    make_unique<ValueExpr>(Value(5000))
));

auto and_expr = make_unique<ConjunctionExpr>(ConjunctionExpr::Type::AND, conditions);
```

## 3. AggregateExpr - 聚合表达式

### 3.1 类结构分析
```cpp
class AggregateExpr : public Expression
{
public:
  enum class Type
  {
    COUNT,  // 计数
    SUM,    // 求和
    AVG,    // 平均值
    MAX,    // 最大值
    MIN,    // 最小值
  };

public:
  AggregateExpr(Type type, Expression *child);
  AggregateExpr(Type type, unique_ptr<Expression> child);
  virtual ~AggregateExpr() = default;

  bool equal(const Expression &other) const override;
  unique_ptr<Expression> copy() const override { 
    return make_unique<AggregateExpr>(aggregate_type_, child_->copy()); 
  }

  ExprType type() const override { return ExprType::AGGREGATION; }
  AttrType value_type() const override { return child_->value_type(); }
  int      value_length() const override { return child_->value_length(); }

  RC get_value(const Tuple &tuple, Value &value) const override;
  RC get_column(Chunk &chunk, Column &column) override;

  Type aggregate_type() const { return aggregate_type_; }
  unique_ptr<Expression> &child() { return child_; }
  const unique_ptr<Expression> &child() const { return child_; }

  // 创建聚合器 - 实际执行聚合计算的对象
  unique_ptr<Aggregator> create_aggregator() const;

  // 从字符串解析聚合类型
  static RC type_from_string(const char *type_str, Type &type);

private:
  Type                   aggregate_type_;  // 聚合类型
  unique_ptr<Expression> child_;           // 被聚合的表达式
};
```

### 3.2 聚合表达式的特殊性

#### 与普通表达式的区别
```cpp
// 普通表达式：输入一行，输出一个值
FieldExpr age_expr(table, age_field);
Value result;
age_expr.get_value(tuple, result);  // 从一行数据中取age字段

// 聚合表达式：输入多行，输出一个值
AggregateExpr sum_age(AggregateExpr::Type::SUM, make_unique<FieldExpr>(table, age_field));
// sum_age.get_value(???, result);  // 需要多行数据，单个tuple不够！
```

#### 聚合器模式
```cpp
// 聚合表达式通过Aggregator来实现实际计算
unique_ptr<Aggregator> create_aggregator() const
{
    switch (aggregate_type_) {
        case Type::COUNT:
            return make_unique<CountAggregator>();
        case Type::SUM:
            return make_unique<SumAggregator>();
        case Type::AVG:
            return make_unique<AvgAggregator>();
        case Type::MAX:
            return make_unique<MaxAggregator>();
        case Type::MIN:
            return make_unique<MinAggregator>();
        default:
            return nullptr;
    }
}
```

### 3.3 Aggregator基类设计
```cpp
class Aggregator {
public:
    virtual ~Aggregator() = default;
    
    // 累积一个值
    virtual RC accumulate(const Value& value) = 0;
    
    // 获取最终结果
    virtual RC evaluate(Value& result) = 0;
    
    // 重置状态
    virtual void reset() = 0;
};

// 具体实现示例
class SumAggregator : public Aggregator {
private:
    Value sum_;
    bool initialized_;
    
public:
    SumAggregator() : initialized_(false) {}
    
    RC accumulate(const Value& value) override {
        if (!initialized_) {
            sum_ = value;
            initialized_ = true;
        } else {
            return Value::add(sum_, value, sum_);
        }
        return RC::SUCCESS;
    }
    
    RC evaluate(Value& result) override {
        result = sum_;
        return RC::SUCCESS;
    }
    
    void reset() override {
        initialized_ = false;
    }
};
```

### 3.4 聚合表达式的使用流程
```cpp
// SQL: SELECT SUM(salary) FROM employees
auto salary_field = make_unique<FieldExpr>(table, salary_field_meta);
auto sum_expr = make_unique<AggregateExpr>(AggregateExpr::Type::SUM, move(salary_field));

// 1. 创建聚合器
auto aggregator = sum_expr->create_aggregator();

// 2. 遍历所有数据行，累积值
for (auto& tuple : all_tuples) {
    Value salary_value;
    sum_expr->child()->get_value(tuple, salary_value);  // 获取salary值
    aggregator->accumulate(salary_value);               // 累积到聚合器
}

// 3. 获取最终结果
Value final_result;
aggregator->evaluate(final_result);  // final_result = 所有salary的和
```

## 4. UnboundAggregateExpr - 未绑定聚合表达式

### 4.1 类似UnboundFieldExpr的设计
```cpp
class UnboundAggregateExpr : public Expression
{
public:
  UnboundAggregateExpr(const char *aggregate_name, Expression *child);
  UnboundAggregateExpr(const char *aggregate_name, unique_ptr<Expression> child);
  virtual ~UnboundAggregateExpr() = default;

  ExprType type() const override { return ExprType::UNBOUND_AGGREGATION; }
  
  unique_ptr<Expression> copy() const override
  {
    return make_unique<UnboundAggregateExpr>(aggregate_name_.c_str(), child_->copy());
  }

  const char *aggregate_name() const { return aggregate_name_.c_str(); }
  unique_ptr<Expression> &child() { return child_; }

  RC       get_value(const Tuple &tuple, Value &value) const override { return RC::INTERNAL; }
  AttrType value_type() const override { return child_->value_type(); }

private:
  string                 aggregate_name_;  // "SUM", "COUNT"等字符串
  unique_ptr<Expression> child_;           // 被聚合的表达式
};
```

### 4.2 绑定过程
```cpp
// SQL解析阶段：
// SELECT SUM(salary) FROM employees
auto unbound = make_unique<UnboundAggregateExpr>("SUM", 
    make_unique<UnboundFieldExpr>("", "salary")
);

// 绑定阶段：
// 1. 解析聚合函数名
AggregateExpr::Type agg_type;
AggregateExpr::type_from_string("SUM", agg_type);  // agg_type = Type::SUM

// 2. 绑定子表达式
auto bound_child = bind_expression(unbound->child());  // UnboundFieldExpr -> FieldExpr

// 3. 创建绑定后的聚合表达式
auto bound = make_unique<AggregateExpr>(agg_type, move(bound_child));
```

## 5. 表达式系统的协同工作

### 5.1 复杂查询示例
```sql
SELECT department, AVG(salary) 
FROM employees 
WHERE age > 25 AND salary > 3000
GROUP BY department
HAVING AVG(salary) > 5000;
```

**对应的表达式树：**
```cpp
// WHERE条件：age > 25 AND salary > 3000
vector<unique_ptr<Expression>> where_conditions;
where_conditions.push_back(make_unique<ComparisonExpr>(GREAT_THAN, 
    make_unique<FieldExpr>(table, age_field), 
    make_unique<ValueExpr>(Value(25))
));
where_conditions.push_back(make_unique<ComparisonExpr>(GREAT_THAN,
    make_unique<FieldExpr>(table, salary_field),
    make_unique<ValueExpr>(Value(3000))
));
auto where_expr = make_unique<ConjunctionExpr>(ConjunctionExpr::Type::AND, where_conditions);

// SELECT列表：department, AVG(salary)
vector<unique_ptr<Expression>> select_exprs;
select_exprs.push_back(make_unique<FieldExpr>(table, dept_field));
select_exprs.push_back(make_unique<AggregateExpr>(AggregateExpr::Type::AVG,
    make_unique<FieldExpr>(table, salary_field)
));

// HAVING条件：AVG(salary) > 5000
auto having_expr = make_unique<ComparisonExpr>(GREAT_THAN,
    make_unique<AggregateExpr>(AggregateExpr::Type::AVG,
        make_unique<FieldExpr>(table, salary_field)
    ),
    make_unique<ValueExpr>(Value(5000))
);
```

表达式系统通过多态、递归和组合等设计模式，实现了从简单常量到复杂聚合查询的统一处理！
